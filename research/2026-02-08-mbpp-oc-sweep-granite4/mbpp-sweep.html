<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>mCode benchmark report | benchmark=mbpp</title>
    <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
    <style>
      body {
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica,
          Arial, sans-serif;
        margin: 24px;
        background: #fff;
        color: #111827;
      }
      .container {
        max-width: 1200px;
        margin: 0 auto;
      }
      #title {
        font-size: 20px;
        font-weight: 700;
        margin: 0 0 6px;
      }
      #subtitle {
        margin: 0 0 14px;
        color: #4b5563;
        font-size: 13px;
        line-height: 1.35;
      }
      .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 10px 12px;
        align-items: center;
        margin: 10px 0 14px;
        font-size: 13px;
        color: #374151;
      }
	      .controls label {
	        display: inline-flex;
	        gap: 6px;
	        align-items: center;
	      }
	      details.dd {
	        position: relative;
	        display: inline-block;
	      }
	      summary.dd-btn {
	        font-size: 13px;
	        padding: 4px 10px;
	        border: 1px solid #d1d5db;
	        border-radius: 8px;
	        background: #fff;
	        color: #111827;
	        cursor: pointer;
	        list-style: none;
	      }
	      summary.dd-btn::-webkit-details-marker {
	        display: none;
	      }
	      summary.dd-btn::marker {
	        content: "";
	      }
	      summary.dd-btn:hover {
	        background: #f9fafb;
	      }
	      details.dd > .dd-menu {
	        display: none;
	      }
	      details.dd[open] > .dd-menu {
	        display: block;
	      }
	      .dd-menu {
	        position: absolute;
	        top: calc(100% + 6px);
	        left: 0;
	        z-index: 1000;
	        min-width: 220px;
	        max-width: 320px;
	        background: #fff;
	        border: 1px solid #e5e7eb;
	        border-radius: 12px;
	        padding: 8px;
	        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
	      }
	      .dd-actions {
	        display: flex;
	        gap: 8px;
	        margin-bottom: 6px;
	      }
	      .dd-action {
	        font-size: 12px;
	        padding: 2px 8px;
	        border: 1px solid #e5e7eb;
	        border-radius: 8px;
	        background: #f9fafb;
	        color: #111827;
	        cursor: pointer;
	      }
	      .dd-action:hover {
	        background: #f3f4f6;
	      }
	      .dd-items {
	        max-height: 240px;
	        overflow: auto;
	      }
	      label.dd-item {
	        display: flex;
	        gap: 8px;
	        align-items: center;
	        width: 100%;
	        box-sizing: border-box;
	        padding: 4px 6px;
	        border-radius: 8px;
	        cursor: pointer;
	        user-select: none;
	      }
	      label.dd-item:hover {
	        background: #f3f4f6;
	      }
	      .dd-item input[type="checkbox"] {
	        margin: 0;
	      }
      select {
        font-size: 13px;
        padding: 4px 8px;
        border: 1px solid #d1d5db;
        border-radius: 8px;
        background: #fff;
        color: #111827;
      }
      input[type="checkbox"] {
        width: 14px;
        height: 14px;
      }
      .plot {
        width: 100%;
        height: 560px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1 id="title"></h1>
      <p id="subtitle"></p>
      <div class="controls" id="controls"></div>
      <div id="scatter" class="plot"></div>
      <div class="controls" id="summary_controls"></div>
      <div id="summary" class="plot" style="height:420px"></div>
    </div>
    <script>
      const BASE_TITLE = "mCode benchmark report | benchmark=mbpp";
      const ROWS = [{"backend_name": "ollama", "benchmark": "mbpp", "max_debug_iterations": 0, "model_id": "granite4:latest", "pass_rate": 0.43, "passed": 43, "retrieval": false, "runs": 20, "samples": 1, "sec_per_solve": 1.3443488372093024, "solves_per_hour": 2677.876381753075, "time_ms_avg": 578.07, "time_ms_p50": 486.0, "time_ms_p95": 1276.35, "time_ms_total": 57807, "time_s_avg": 0.5780700000000001, "time_s_p50": 0.486, "time_s_p95": 1.2763499999999999, "time_s_total": 57.807, "timeout_s": 60, "total": 100}, {"backend_name": "ollama", "benchmark": "mbpp", "max_debug_iterations": 0, "model_id": "granite4:latest", "pass_rate": 0.6, "passed": 60, "retrieval": false, "runs": 20, "samples": 2, "sec_per_solve": 1.4921499999999999, "solves_per_hour": 2412.626076466843, "time_ms_avg": 895.29, "time_ms_p50": 778.0, "time_ms_p95": 1946.6499999999996, "time_ms_total": 89529, "time_s_avg": 0.8952899999999999, "time_s_p50": 0.778, "time_s_p95": 1.9466499999999995, "time_s_total": 89.529, "timeout_s": 60, "total": 100}, {"backend_name": "ollama", "benchmark": "mbpp", "max_debug_iterations": 0, "model_id": "granite4:latest", "pass_rate": 0.65, "passed": 65, "retrieval": false, "runs": 20, "samples": 3, "sec_per_solve": 2.7041384615384616, "solves_per_hour": 1331.292776314367, "time_ms_avg": 1757.69, "time_ms_p50": 1512.5, "time_ms_p95": 3896.7, "time_ms_total": 175769, "time_s_avg": 1.75769, "time_s_p50": 1.5125, "time_s_p95": 3.8966999999999996, "time_s_total": 175.769, "timeout_s": 60, "total": 100}, {"backend_name": "ollama", "benchmark": "mbpp", "max_debug_iterations": 0, "model_id": "granite4:latest", "pass_rate": 0.45, "passed": 45, "retrieval": false, "runs": 20, "samples": 1, "sec_per_solve": 1.6870222222222222, "solves_per_hour": 2133.9375098793403, "time_ms_avg": 759.16, "time_ms_p50": 547.5, "time_ms_p95": 2086.7999999999997, "time_ms_total": 75916, "time_s_avg": 0.75916, "time_s_p50": 0.5475, "time_s_p95": 2.0867999999999998, "time_s_total": 75.916, "timeout_s": 120, "total": 100}, {"backend_name": "ollama", "benchmark": "mbpp", "max_debug_iterations": 0, "model_id": "granite4:latest", "pass_rate": 0.61, "passed": 61, "retrieval": false, "runs": 20, "samples": 2, "sec_per_solve": 1.7392295081967213, "solves_per_hour": 2069.882084586165, "time_ms_avg": 1060.93, "time_ms_p50": 972.0, "time_ms_p95": 2288.4999999999995, "time_ms_total": 106093, "time_s_avg": 1.0609300000000002, "time_s_p50": 0.972, "time_s_p95": 2.2884999999999995, "time_s_total": 106.093, "timeout_s": 120, "total": 100}, {"backend_name": "ollama", "benchmark": "mbpp", "max_debug_iterations": 0, "model_id": "granite4:latest", "pass_rate": 0.63, "passed": 63, "retrieval": false, "runs": 20, "samples": 3, "sec_per_solve": 8.632063492063493, "solves_per_hour": 417.0497591114707, "time_ms_avg": 5438.2, "time_ms_p50": 1013.0, "time_ms_p95": 3422.149999999999, "time_ms_total": 543820, "time_s_avg": 5.4382, "time_s_p50": 1.013, "time_s_p95": 3.4221499999999994, "time_s_total": 543.82, "timeout_s": 120, "total": 100}, {"backend_name": "ollama", "benchmark": "mbpp", "max_debug_iterations": 1, "model_id": "granite4:latest", "pass_rate": 0.57, "passed": 57, "retrieval": false, "runs": 20, "samples": 1, "sec_per_solve": 3.7177543859649123, "solves_per_hour": 968.3264751406244, "time_ms_avg": 2119.12, "time_ms_p50": 687.0, "time_ms_p95": 2172.6499999999996, "time_ms_total": 211912, "time_s_avg": 2.1191199999999997, "time_s_p50": 0.687, "time_s_p95": 2.1726499999999995, "time_s_total": 211.912, "timeout_s": 60, "total": 100}, {"backend_name": "ollama", "benchmark": "mbpp", "max_debug_iterations": 1, "model_id": "granite4:latest", "pass_rate": 0.63, "passed": 63, "retrieval": false, "runs": 20, "samples": 2, "sec_per_solve": 3.1456666666666666, "solves_per_hour": 1144.431493059235, "time_ms_avg": 1981.77, "time_ms_p50": 1683.0, "time_ms_p95": 5450.3, "time_ms_total": 198177, "time_s_avg": 1.98177, "time_s_p50": 1.683, "time_s_p95": 5.4503, "time_s_total": 198.177, "timeout_s": 60, "total": 100}, {"backend_name": "ollama", "benchmark": "mbpp", "max_debug_iterations": 1, "model_id": "granite4:latest", "pass_rate": 0.74, "passed": 74, "retrieval": false, "runs": 20, "samples": 3, "sec_per_solve": 3.225135135135135, "solves_per_hour": 1116.232296991536, "time_ms_avg": 2386.6, "time_ms_p50": 1259.0, "time_ms_p95": 7464.0999999999985, "time_ms_total": 238660, "time_s_avg": 2.3866, "time_s_p50": 1.259, "time_s_p95": 7.464099999999998, "time_s_total": 238.66, "timeout_s": 60, "total": 100}, {"backend_name": "ollama", "benchmark": "mbpp", "max_debug_iterations": 1, "model_id": "granite4:latest", "pass_rate": 0.51, "passed": 51, "retrieval": false, "runs": 20, "samples": 1, "sec_per_solve": 10.801117647058822, "solves_per_hour": 333.2988416231436, "time_ms_avg": 5508.57, "time_ms_p50": 1113.5, "time_ms_p95": 2900.3999999999996, "time_ms_total": 550857, "time_s_avg": 5.50857, "time_s_p50": 1.1135, "time_s_p95": 2.9003999999999994, "time_s_total": 550.857, "timeout_s": 120, "total": 100}, {"backend_name": "ollama", "benchmark": "mbpp", "max_debug_iterations": 1, "model_id": "granite4:latest", "pass_rate": 0.65, "passed": 65, "retrieval": false, "runs": 20, "samples": 2, "sec_per_solve": 3.002646153846154, "solves_per_hour": 1198.9424712561229, "time_ms_avg": 1951.72, "time_ms_p50": 1375.0, "time_ms_p95": 4824.049999999998, "time_ms_total": 195172, "time_s_avg": 1.9517200000000001, "time_s_p50": 1.375, "time_s_p95": 4.824049999999998, "time_s_total": 195.172, "timeout_s": 120, "total": 100}, {"backend_name": "ollama", "benchmark": "mbpp", "max_debug_iterations": 1, "model_id": "granite4:latest", "pass_rate": 0.72, "passed": 72, "retrieval": false, "runs": 20, "samples": 3, "sec_per_solve": 12.3695, "solves_per_hour": 291.03844132745866, "time_ms_avg": 8906.04, "time_ms_p50": 1245.0, "time_ms_p95": 9062.8, "time_ms_total": 890604, "time_s_avg": 8.90604, "time_s_p50": 1.245, "time_s_p95": 9.0628, "time_s_total": 890.604, "timeout_s": 120, "total": 100}, {"backend_name": "ollama", "benchmark": "mbpp", "max_debug_iterations": 2, "model_id": "granite4:latest", "pass_rate": 0.59, "passed": 59, "retrieval": false, "runs": 20, "samples": 1, "sec_per_solve": 3.0526101694915257, "solves_per_hour": 1179.318615910807, "time_ms_avg": 1801.04, "time_ms_p50": 1329.5, "time_ms_p95": 5026.799999999999, "time_ms_total": 180104, "time_s_avg": 1.80104, "time_s_p50": 1.3295, "time_s_p95": 5.0268, "time_s_total": 180.104, "timeout_s": 60, "total": 100}, {"backend_name": "ollama", "benchmark": "mbpp", "max_debug_iterations": 2, "model_id": "granite4:latest", "pass_rate": 0.58, "passed": 58, "retrieval": false, "runs": 20, "samples": 2, "sec_per_solve": 5.259965517241379, "solves_per_hour": 684.4151331790559, "time_ms_avg": 3050.78, "time_ms_p50": 2259.5, "time_ms_p95": 8575.549999999994, "time_ms_total": 305078, "time_s_avg": 3.05078, "time_s_p50": 2.2595, "time_s_p95": 8.575549999999994, "time_s_total": 305.078, "timeout_s": 60, "total": 100}, {"backend_name": "ollama", "benchmark": "mbpp", "max_debug_iterations": 2, "model_id": "granite4:latest", "pass_rate": 0.74, "passed": 74, "retrieval": false, "runs": 20, "samples": 3, "sec_per_solve": 11.627635135135137, "solves_per_hour": 309.60723811516135, "time_ms_avg": 8604.45, "time_ms_p50": 1769.0, "time_ms_p95": 18314.649999999994, "time_ms_total": 860445, "time_s_avg": 8.60445, "time_s_p50": 1.769, "time_s_p95": 18.314649999999993, "time_s_total": 860.445, "timeout_s": 60, "total": 100}, {"backend_name": "ollama", "benchmark": "mbpp", "max_debug_iterations": 2, "model_id": "granite4:latest", "pass_rate": 0.54, "passed": 54, "retrieval": false, "runs": 20, "samples": 1, "sec_per_solve": 3.5749259259259256, "solves_per_hour": 1007.0138723413073, "time_ms_avg": 1930.46, "time_ms_p50": 1426.5, "time_ms_p95": 5011.349999999999, "time_ms_total": 193046, "time_s_avg": 1.93046, "time_s_p50": 1.4265, "time_s_p95": 5.011349999999999, "time_s_total": 193.046, "timeout_s": 120, "total": 100}, {"backend_name": "ollama", "benchmark": "mbpp", "max_debug_iterations": 2, "model_id": "granite4:latest", "pass_rate": 0.72, "passed": 72, "retrieval": false, "runs": 20, "samples": 2, "sec_per_solve": 9.943388888888888, "solves_per_hour": 362.04960303048927, "time_ms_avg": 7159.24, "time_ms_p50": 1721.5, "time_ms_p95": 9106.699999999997, "time_ms_total": 715924, "time_s_avg": 7.15924, "time_s_p50": 1.7215, "time_s_p95": 9.106699999999996, "time_s_total": 715.924, "timeout_s": 120, "total": 100}, {"backend_name": "ollama", "benchmark": "mbpp", "max_debug_iterations": 2, "model_id": "granite4:latest", "pass_rate": 0.71, "passed": 71, "retrieval": false, "runs": 20, "samples": 3, "sec_per_solve": 18.607535211267606, "solves_per_hour": 193.4700087424828, "time_ms_avg": 13211.35, "time_ms_p50": 2278.5, "time_ms_p95": 51733.399999999776, "time_ms_total": 1321135, "time_s_avg": 13.21135, "time_s_p50": 2.2785, "time_s_p95": 51.733399999999776, "time_s_total": 1321.135, "timeout_s": 120, "total": 100}];

      function showError(msg) {
        const p = document.createElement("p");
        p.style.margin = "10px 0 0";
        p.style.color = "#b91c1c";
        p.style.fontSize = "13px";
        p.textContent = "Report error: " + msg;
        const anchor = document.getElementById("scatter");
        if (anchor && anchor.parentElement) {
          anchor.parentElement.insertBefore(p, anchor);
        } else {
          document.body.appendChild(p);
        }
      }

      window.addEventListener("error", (e) => {
        if (e && e.message) showError(e.message);
      });
      window.addEventListener("unhandledrejection", (e) => {
        const reason = (e && e.reason) ? String(e.reason) : "unhandled promise rejection";
        showError(reason);
      });

      if (typeof Plotly === "undefined") {
        showError("Plotly failed to load. If you're offline or the CDN is blocked, the graphs won't render.");
      }

      const CONTROLS = document.getElementById("controls");
      const SUMMARY_CONTROLS = document.getElementById("summary_controls");

	      function uniqVals(rs, field) {
	        const s = new Set();
	        for (const r of rs) {
	          const v = r[field];
	          if (v === undefined || v === null) continue;
	          s.add(JSON.stringify(v));
	        }
	        return Array.from(s).map(x => JSON.parse(x));
	      }

	      function constantValue(rs, field) {
	        const u = uniqVals(rs, field);
	        return (u.length === 1) ? u[0] : null;
	      }

      function fmtBool(v) {
        return v ? "on" : "off";
      }

      function fmtTimeout(v) {
        return `${v}s`;
      }

      function valueKey(v) {
        return JSON.stringify(v);
      }

      const points = ROWS.filter(r => r.sec_per_solve !== null && r.sec_per_solve !== undefined);
      const dropped = ROWS.length - points.length;

      // Promote constants into the title, and omit them from per-point labels.
      let finalTitle = BASE_TITLE;
      const fixed = {
        benchmark: constantValue(points, "benchmark"),
        backend: constantValue(points, "backend_name"),
        model: constantValue(points, "model_id"),
        retrieval: constantValue(points, "retrieval"),
      };
      function maybeAppendTitle(k, v) {
        if (v === null || v === undefined) return;
        const needle = `${k}=`;
        if (finalTitle.includes(needle)) return;
        finalTitle += ` | ${k}=${v}`;
      }
      maybeAppendTitle("benchmark", fixed.benchmark);
      maybeAppendTitle("backend", fixed.backend);
      maybeAppendTitle("model", fixed.model);
      if (fixed.retrieval !== null) maybeAppendTitle("retrieval", fmtBool(fixed.retrieval));

      document.getElementById("title").textContent = finalTitle;
      const fixedTokens = [];
      const fixedSamples = constantValue(points, "samples");
      const fixedDebug = constantValue(points, "max_debug_iterations");
      const fixedTimeout = constantValue(points, "timeout_s");
      if (fixedSamples !== null && fixedSamples !== undefined) fixedTokens.push(`s=${fixedSamples}`);
      if (fixedDebug !== null && fixedDebug !== undefined) fixedTokens.push(`d=${fixedDebug}`);
      if (fixedTimeout !== null && fixedTimeout !== undefined) fixedTokens.push(`t=${fixedTimeout}s`);

      let subtitle =
        `Plotting ${points.length} configs` + (dropped ? ` (hidden: ${dropped} with 0 solves)` : "") +
        ". X = seconds/solve (lower is better). Y = pass rate (higher is better).";
      if (fixedTokens.length) subtitle += ` Fixed: ${fixedTokens.join(" ")}.`;
      document.getElementById("subtitle").textContent = subtitle;

      const CONFIG_FIELDS = [
        ["benchmark", "Benchmark"],
        ["backend_name", "Backend"],
        ["model_id", "Model"],
        ["samples", "Samples"],
        ["max_debug_iterations", "Debug"],
        ["timeout_s", "Timeout"],
        ["retrieval", "Retrieval"],
      ];

      const varying = new Map();
      for (const [f] of CONFIG_FIELDS) {
        varying.set(f, uniqVals(points, f).length > 1);
      }

      function fmtValue(field, v) {
        if (field === "retrieval") return fmtBool(!!v);
        if (field === "timeout_s") return fmtTimeout(v);
        return String(v);
      }

      function shortToken(field, v) {
        if (field === "samples") return `s=${v}`;
        if (field === "max_debug_iterations") return `d=${v}`;
        if (field === "timeout_s") return `t=${v}s`;
        if (field === "retrieval") return `r=${fmtBool(!!v)}`;
        if (field === "benchmark") return String(v);
        if (field === "backend_name") return `backend=${v}`;
        if (field === "model_id") return `model=${v}`;
        return `${field}=${v}`;
      }

      function label(r) {
        const parts = [];
        if (r.run_id !== undefined && r.run_id !== null) parts.push(`run=${r.run_id}`);
        for (const [f] of CONFIG_FIELDS) {
          if (!varying.get(f)) continue;
          const v = r[f];
          if (v === undefined || v === null) continue;
          parts.push(shortToken(f, v));
        }
        if (r.runs !== undefined && r.runs !== null && r.runs > 0) parts.push(`runs=${r.runs}`);
        return parts.join(" ");
      }

	      function paretoFrontier(rs) {
	        // Maximize pass_rate, minimize sec_per_solve.
	        const pts = rs
	          .filter(r => r.sec_per_solve !== null && r.sec_per_solve !== undefined)
	          .filter(r => r.pass_rate !== null && r.pass_rate !== undefined)
	          .map(r => ({ r, x: Number(r.sec_per_solve), y: Number(r.pass_rate) }))
	          .filter(p => Number.isFinite(p.x) && Number.isFinite(p.y))
	          // Sort by x asc, then y desc. Keep strictly improving y as x increases.
	          .sort((a, b) => (a.x - b.x) || (b.y - a.y));

	        const out = [];
	        let bestY = -Infinity;
	        for (const p of pts) {
	          if (p.y > bestY) {
	            out.push(p);
	            bestY = p.y;
	          }
	        }
	        return out;
	      }

      const PALETTE = ["#2563eb", "#dc2626", "#16a34a", "#7c3aed", "#ea580c", "#0891b2", "#6b7280"];
      const COLOR_PRIORITY = ["samples", "max_debug_iterations", "timeout_s", "retrieval", "benchmark", "model_id", "backend_name"];

	      function buildSelect(id, labelText, options, initial) {
	        const wrap = document.createElement("label");
	        wrap.htmlFor = id;
	        wrap.textContent = labelText;
	        const sel = document.createElement("select");
        sel.id = id;
        for (const [value, text] of options) {
          const opt = document.createElement("option");
          opt.value = value;
          opt.textContent = text;
          if (value === initial) opt.selected = true;
          sel.appendChild(opt);
        }
	        wrap.appendChild(sel);
	        return sel;
	      }

	      function buildCheckbox(id, labelText, initial) {
	        const wrap = document.createElement("label");
	        const cb = document.createElement("input");
	        cb.type = "checkbox";
	        cb.id = id;
	        cb.checked = !!initial;
	        wrap.appendChild(cb);
	        const span = document.createElement("span");
	        span.textContent = labelText;
	        wrap.appendChild(span);
	        return cb;
	      }

	      function buildMultiSelectDropdown(field, labelText, values) {
	        const wrap = document.createElement("details");
	        wrap.className = "dd";

	        const summary = document.createElement("summary");
	        summary.className = "dd-btn";

	        const menu = document.createElement("div");
	        menu.className = "dd-menu";

	        const actions = document.createElement("div");
	        actions.className = "dd-actions";
	        const allBtn = document.createElement("button");
	        allBtn.type = "button";
	        allBtn.className = "dd-action";
	        allBtn.textContent = "All";
	        const noneBtn = document.createElement("button");
	        noneBtn.type = "button";
	        noneBtn.className = "dd-action";
	        noneBtn.textContent = "None";
	        actions.appendChild(allBtn);
	        actions.appendChild(noneBtn);

	        const items = document.createElement("div");
	        items.className = "dd-items";

	        const checkboxes = [];
	        for (const v of values) {
	          const lab = document.createElement("label");
	          lab.className = "dd-item";
	          const cb = document.createElement("input");
	          cb.type = "checkbox";
	          cb.checked = true;
	          cb.dataset.field = field;
	          cb.dataset.key = valueKey(v);
	          lab.appendChild(cb);
	          const span = document.createElement("span");
	          span.textContent = fmtValue(field, v);
	          lab.appendChild(span);
	          items.appendChild(lab);
	          checkboxes.push(cb);
	        }

	        function update() {
	          const selected = checkboxes.filter(cb => cb.checked).map(cb => JSON.parse(cb.dataset.key));
	          let summaryText = "all";
	          if (selected.length === 0) summaryText = "none";
	          else if (selected.length !== checkboxes.length) {
	            const texts = selected.map(v => fmtValue(field, v));
	            summaryText = (texts.length <= 3) ? texts.join(", ") : `${texts.length}/${checkboxes.length}`;
	          }
	          summary.textContent = `${labelText}: ${truncate(summaryText, 28)} ▾`;
	        }

	        update();

	        allBtn.addEventListener("click", (e) => {
	          e.preventDefault();
	          for (const cb of checkboxes) cb.checked = true;
	          update();
	          render();
	        });
	        noneBtn.addEventListener("click", (e) => {
	          e.preventDefault();
	          for (const cb of checkboxes) cb.checked = false;
	          update();
	          render();
	        });

	        wrap.appendChild(summary);
	        menu.appendChild(actions);
	        menu.appendChild(items);
	        wrap.appendChild(menu);

	        return { wrap, checkboxes, update };
	      }

      function varyingFields() {
        const out = [];
        for (const [f] of CONFIG_FIELDS) {
          if (varying.get(f)) out.push(f);
        }
        return out;
      }

	      const vfields = varyingFields();

	      // Filters: allow narrowing by any varying config field, while staying compact.
	      const filterCheckboxes = new Map();
	      const filterUpdaters = new Map();

	      function sortedUnique(field) {
	        const u = uniqVals(points, field);
	        return u.slice().sort((a, b) => {
	          const na = Number(a), nb = Number(b);
	          if (!Number.isNaN(na) && !Number.isNaN(nb)) return na - nb;
	          return String(a).localeCompare(String(b));
	        });
	      }

	      function currentFilters() {
	        const out = new Map();
	        for (const [f, cbs] of filterCheckboxes.entries()) {
	          const selected = cbs.filter(cb => cb.checked).map(cb => cb.dataset.key);
	          if (selected.length === cbs.length) continue; // no-op filter
	          out.set(f, new Set(selected));
	        }
	        return out;
	      }

      function applyFilters(rs, filters) {
        if (!filters.size) return rs;
        return rs.filter(r => {
          for (const [f, set] of filters.entries()) {
            if (!set.has(valueKey(r[f]))) return false;
          }
          return true;
        });
      }

      function colorableFields() {
        const out = [];
        for (const f of vfields) {
          // Keep the legend readable.
          if (uniqVals(points, f).length <= 12) out.push(f);
        }
        return out;
      }

      const cfields = colorableFields();

      let defaultColorBy = "none";
      for (const f of COLOR_PRIORITY) {
        if (cfields.includes(f)) { defaultColorBy = f; break; }
      }

      // Controls: keep it minimal.
      const colorOptions = [["none", "none"]];
	      for (const f of cfields) {
	        const label = CONFIG_FIELDS.find(x => x[0] === f)?.[1] ?? f;
	        colorOptions.push([f, label]);
	      }
	      const colorBySel = buildSelect("color_by", "Color:", colorOptions, defaultColorBy);
	      const paretoCb = buildCheckbox("show_pareto", "Best tradeoffs (Pareto)", true);
	      const onlyFrontierCb = buildCheckbox("only_frontier", "Only best tradeoffs", false);
	      paretoCb.parentElement.title = "Best tradeoffs = configs where no other config is both faster and more accurate.";
	      onlyFrontierCb.parentElement.title = "Hide configs that are dominated on both accuracy and speed.";

	      CONTROLS.appendChild(colorBySel.parentElement);
	      CONTROLS.appendChild(paretoCb.parentElement);
	      CONTROLS.appendChild(onlyFrontierCb.parentElement);

	      // Summary controls (simple + focused on accuracy/speed).
	      const summarySetSel = buildSelect(
	        "summary_set",
	        "Summary:",
	        [["frontier", "best tradeoffs"], ["shown", "all shown"]],
	        "frontier",
	      );
	      const speedMetricSel = buildSelect(
	        "speed_metric",
	        "Speed:",
	        [
	          ["sec_per_solve", "sec/solve"],
	          ["time_s_avg", "avg_s"],
	          ["time_s_p95", "p95_s"],
	        ],
	        "sec_per_solve",
	      );
	      speedMetricSel.parentElement.title =
	        "sec/solve = total seconds / passed tasks. avg_s = mean seconds per task. p95_s = 95th percentile seconds per task.";
	      const summaryViewSel = buildSelect(
	        "summary_view",
	        "View:",
	        [["split", "split"], ["overlay", "overlay"]],
	        "split",
	      );
	      const defaultTop = (points.length <= 20) ? "all" : "20";
	      const topNSel = buildSelect(
	        "top_n",
	        "Top:",
	        [["5", "5"], ["10", "10"], ["15", "15"], ["20", "20"], ["30", "30"], ["all", "all"]],
	        defaultTop,
	      );

	      SUMMARY_CONTROLS.appendChild(summarySetSel.parentElement);
	      SUMMARY_CONTROLS.appendChild(speedMetricSel.parentElement);
	      SUMMARY_CONTROLS.appendChild(summaryViewSel.parentElement);
	      SUMMARY_CONTROLS.appendChild(topNSel.parentElement);

	      for (const f of vfields) {
	        const label = CONFIG_FIELDS.find(x => x[0] === f)?.[1] ?? f;
	        const u = sortedUnique(f);
	        const dd = buildMultiSelectDropdown(f, label, u);
	        filterCheckboxes.set(f, dd.checkboxes);
	        filterUpdaters.set(f, dd.update);
	        SUMMARY_CONTROLS.appendChild(dd.wrap);
	      }

      function makeTraces(rs, colorBy) {
        const baseCustom = r => [
          r.total, r.passed, r.time_s_avg, r.time_s_p50, r.time_s_p95,
        ];
        const hover =
          "%{text}" +
          "<br>pass_rate=%{y:.1%}" +
          "<br>sec/solve=%{x:.2f}" +
          "<br>avg_s=%{customdata[2]:.2f}" +
          "<br>p50_s=%{customdata[3]:.2f}" +
          "<br>p95_s=%{customdata[4]:.2f}" +
          "<br>passed=%{customdata[1]}/%{customdata[0]}" +
          "<extra></extra>";

        if (!colorBy || colorBy === "none") {
          return [{
            type: "scatter",
            mode: "markers",
            name: "configs",
            x: rs.map(r => r.sec_per_solve),
            y: rs.map(r => r.pass_rate),
            text: rs.map(r => label(r)),
            customdata: rs.map(baseCustom),
            hovertemplate: hover,
            marker: {
              size: 10,
              opacity: 0.9,
              color: "#2563eb",
              line: { width: 1, color: "rgba(0,0,0,0.18)" },
            },
          }];
        }

        const u = uniqVals(rs, colorBy);
        const sorted = u.slice().sort((a, b) => {
          const na = Number(a), nb = Number(b);
          if (!Number.isNaN(na) && !Number.isNaN(nb)) return na - nb;
          return String(a).localeCompare(String(b));
        });
        const traces = [];
        for (let i = 0; i < sorted.length; i++) {
          const v = sorted[i];
          const sub = rs.filter(r => r[colorBy] === v);
          traces.push({
            type: "scatter",
            mode: "markers",
            name: `${CONFIG_FIELDS.find(x => x[0] === colorBy)?.[1] ?? colorBy}=${fmtValue(colorBy, v)}`,
            x: sub.map(r => r.sec_per_solve),
            y: sub.map(r => r.pass_rate),
            text: sub.map(r => label(r)),
            customdata: sub.map(baseCustom),
            hovertemplate: hover,
            marker: {
              size: 10,
              opacity: 0.9,
              color: PALETTE[i % PALETTE.length],
              line: { width: 1, color: "rgba(0,0,0,0.18)" },
            },
          });
        }
        return traces;
      }

      function truncate(s, maxLen) {
        const text = String(s ?? "");
        if (text.length <= maxLen) return text;
        return text.slice(0, Math.max(0, maxLen - 1)) + "…";
      }

      function axisLabel(r) {
        const parts = [];
        if (r.run_id !== undefined && r.run_id !== null) parts.push(`run=${r.run_id}`);
        for (const [f] of CONFIG_FIELDS) {
          if (!varying.get(f)) continue;
          const v = r[f];
          if (v === undefined || v === null) continue;
          parts.push(shortToken(f, v));
        }
        return parts.join(" ");
      }

	      function renderSummary(rs, setName, speedField, viewMode) {
	        const rows = rs
	          .filter(r => r.pass_rate !== null && r.pass_rate !== undefined)
	          .filter(r => r[speedField] !== null && r[speedField] !== undefined)
	          .slice();

        const speedTitle =
          (speedMetricSel.options && speedMetricSel.selectedIndex >= 0)
            ? speedMetricSel.options[speedMetricSel.selectedIndex].textContent
            : speedField;

        if (rows.length === 0) {
          Plotly.react("summary", [], {
            title: `Summary (${setName})`,
            template: "plotly_white",
          }, { displaylogo: false, responsive: true });
          return;
        }

        // Lower is better for speed metrics.
        rows.sort((a, b) => Number(a[speedField]) - Number(b[speedField]));

        const ids = rows.map((_, i) => String(i + 1));
        const ticks = rows.map(r => truncate(axisLabel(r) || "config", 64));
        const pass = rows.map(r => Number(r.pass_rate));
        const speed = rows.map(r => Number(r[speedField]));
        const details = rows.map(r => label(r));

	        const height = Math.max(260, Math.min(1400, 140 + rows.length * 28));
	        const summaryDiv = document.getElementById("summary");
	        if (summaryDiv) summaryDiv.style.height = height + "px";

	        const overlay = (viewMode === "overlay");
	        const passTrace = {
	          type: "bar",
	          orientation: "h",
	          name: "pass_rate",
	          x: pass,
	          y: ids,
	          xaxis: "x",
	          marker: { color: overlay ? "rgba(37,99,235,0.70)" : "rgba(37,99,235,0.75)" },
	          width: overlay ? 0.70 : undefined,
	          customdata: details,
	          hovertemplate: "%{customdata}<br>pass_rate=%{x:.1%}<extra></extra>",
	        };
	        const speedTrace = {
	          type: "bar",
	          orientation: "h",
	          name: speedTitle,
	          x: speed,
	          y: ids,
	          xaxis: "x2",
	          marker: { color: overlay ? "rgba(17,24,39,0.28)" : "rgba(17,24,39,0.20)" },
	          width: overlay ? 0.34 : undefined,
	          customdata: details,
	          hovertemplate: "%{customdata}<br>" + speedTitle + "=%{x:.2f}<extra></extra>",
	        };

	        Plotly.react("summary", [
	          passTrace,
	          speedTrace,
	        ], {
	          title: `Summary (${setName}, n=${rows.length})`,
	          showlegend: false,
	          barmode: "overlay",
	          template: "plotly_white",
	          margin: { t: overlay ? 80 : 60, r: 55, b: 30, l: 10 },
	          yaxis: {
	            tickvals: ids,
	            ticktext: ticks,
	            tickfont: { size: 11 },
	            automargin: true,
	            autorange: "reversed",
	          },
	          xaxis: {
	            domain: overlay ? [0.0, 1.0] : [0.0, 0.47],
	            title: "pass rate",
	            tickformat: ".0%",
	            range: [0, 1],
	            gridcolor: "rgba(0,0,0,0.06)",
	            zerolinecolor: "rgba(0,0,0,0.12)",
	          },
	          xaxis2: {
	            domain: overlay ? [0.0, 1.0] : [0.53, 1.0],
	            overlaying: overlay ? "x" : undefined,
	            side: overlay ? "top" : undefined,
	            title: speedTitle,
	            rangemode: "tozero",
	            showgrid: overlay ? false : true,
	            gridcolor: "rgba(0,0,0,0.06)",
	            zerolinecolor: "rgba(0,0,0,0.12)",
	          },
	          shapes: overlay
	            ? []
	            : [{
	              type: "line",
	              xref: "paper",
	              yref: "paper",
	              x0: 0.5,
	              x1: 0.5,
	              y0: 0,
	              y1: 1,
	              line: { color: "rgba(0,0,0,0.12)", width: 1 },
	            }],
	        }, {
	          displaylogo: false,
	          responsive: true,
	        });
      }

	      function render() {
	        for (const u of filterUpdaters.values()) u();
	        const colorBy = colorBySel.value;
	        const filters = currentFilters();
	        const base = applyFilters(points, filters);
	        const frontierPts = paretoFrontier(base);
	        const frontierRows = frontierPts.map(p => p.r);

        let rs = base;
        if (onlyFrontierCb.checked) {
          const fset = new Set(frontierRows);
          rs = base.filter(r => fset.has(r));
        }

        const shownText =
          (base.length === points.length)
            ? `Showing ${base.length} configs. `
            : `Showing ${base.length} / ${points.length} configs (filtered). `;
        const fixedText = fixedTokens.length ? `Fixed: ${fixedTokens.join(" ")}.` : "";
        document.getElementById("subtitle").textContent =
          shownText + "X = seconds/solve (lower is better). Y = pass rate (higher is better). " + fixedText;

	        const traces = makeTraces(rs, colorBy);
	        if (paretoCb.checked && frontierPts.length >= 2) {
	          traces.push({
	            type: "scatter",
	            mode: "lines",
	            name: "Best tradeoffs",
	            x: frontierPts.map(p => p.x),
	            y: frontierPts.map(p => p.y),
	            hoverinfo: "skip",
	            line: { color: "rgba(17,24,39,0.55)", width: 2, dash: "dot" },
	          });
	        }

	        Plotly.react("scatter", traces, {
	          title: "Pass rate vs seconds/solve",
	          xaxis: {
	            title: { text: "seconds per solve (lower is better)", standoff: 18 },
	            rangemode: "tozero",
	          },
	          yaxis: {
	            title: { text: "pass rate (higher is better)", standoff: 10 },
	            tickformat: ".0%",
	            rangemode: "tozero",
	          },
	          legend: {
	            orientation: "h",
	            y: -0.50,
	            yanchor: "top",
	            x: 0,
	            xanchor: "left",
	          },
	          margin: { t: 60, r: 20, b: 150, l: 65 },
	          template: "plotly_white",
	        }, {
          displaylogo: false,
          responsive: true,
        });

	        const speedField = speedMetricSel.value;
	        const summarySet = summarySetSel.value;
	        const viewMode = summaryViewSel.value;
	        let summaryRows = (summarySet === "shown") ? rs.slice() : frontierRows.slice();
	        summaryRows = summaryRows
	          .filter(r => r[speedField] !== null && r[speedField] !== undefined)
	          .sort((a, b) => Number(a[speedField]) - Number(b[speedField]));

        const topVal = topNSel.value;
        if (topVal !== "all") {
          const n = parseInt(topVal, 10);
          if (!Number.isNaN(n) && n > 0) summaryRows = summaryRows.slice(0, n);
        }
	        const summarySetName =
	          (summarySetSel.options && summarySetSel.selectedIndex >= 0)
	            ? summarySetSel.options[summarySetSel.selectedIndex].textContent
	            : summarySet;
	        renderSummary(summaryRows, summarySetName, speedField, viewMode);
	      }

      colorBySel.addEventListener("change", render);
      paretoCb.addEventListener("change", render);
      onlyFrontierCb.addEventListener("change", render);
	      for (const cbs of filterCheckboxes.values()) {
	        for (const cb of cbs) cb.addEventListener("change", render);
	      }
	      summarySetSel.addEventListener("change", render);
	      speedMetricSel.addEventListener("change", render);
	      summaryViewSel.addEventListener("change", render);
	      topNSel.addEventListener("change", render);

      render();
    </script>
  </body>
</html>
