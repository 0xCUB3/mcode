<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>mCode benchmark report | benchmark=mbpp</title>
    <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
    <style>
      body {
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica,
          Arial, sans-serif;
        margin: 24px;
        background: #fff;
        color: #111827;
      }
      .container {
        max-width: 1200px;
        margin: 0 auto;
      }
      #title {
        font-size: 20px;
        font-weight: 700;
        margin: 0 0 6px;
      }
      #subtitle {
        margin: 0 0 14px;
        color: #4b5563;
        font-size: 13px;
        line-height: 1.35;
      }
      .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 10px 12px;
        align-items: center;
        margin: 10px 0 14px;
        font-size: 13px;
        color: #374151;
      }
        .controls label {
          display: inline-flex;
          gap: 6px;
          align-items: center;
        }
        details.dd {
          position: relative;
          display: inline-block;
        }
        summary.dd-btn {
          font-size: 13px;
          padding: 4px 10px;
          border: 1px solid #d1d5db;
          border-radius: 8px;
          background: #fff;
          color: #111827;
          cursor: pointer;
          list-style: none;
        }
        summary.dd-btn::-webkit-details-marker {
          display: none;
        }
        summary.dd-btn::marker {
          content: "";
        }
        summary.dd-btn:hover {
          background: #f9fafb;
        }
        details.dd > .dd-menu {
          display: none;
        }
        details.dd[open] > .dd-menu {
          display: block;
        }
        .dd-menu {
          position: absolute;
          top: calc(100% + 6px);
          left: 0;
          z-index: 1000;
          min-width: 220px;
          max-width: 320px;
          background: #fff;
          border: 1px solid #e5e7eb;
          border-radius: 12px;
          padding: 8px;
          box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
        }
        .dd-actions {
          display: flex;
          gap: 8px;
          margin-bottom: 6px;
        }
        .dd-action {
          font-size: 12px;
          padding: 2px 8px;
          border: 1px solid #e5e7eb;
          border-radius: 8px;
          background: #f9fafb;
          color: #111827;
          cursor: pointer;
        }
        .dd-action:hover {
          background: #f3f4f6;
        }
        .dd-items {
          max-height: 240px;
          overflow: auto;
        }
        label.dd-item {
          display: flex;
          gap: 8px;
          align-items: center;
          width: 100%;
          box-sizing: border-box;
          padding: 4px 6px;
          border-radius: 8px;
          cursor: pointer;
          user-select: none;
        }
        label.dd-item:hover {
          background: #f3f4f6;
        }
        .dd-item input[type="checkbox"] {
          margin: 0;
        }
      select {
        font-size: 13px;
        padding: 4px 8px;
        border: 1px solid #d1d5db;
        border-radius: 8px;
        background: #fff;
        color: #111827;
      }
      input[type="checkbox"] {
        width: 14px;
        height: 14px;
      }
      .plot {
        width: 100%;
        height: 560px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1 id="title"></h1>
      <p id="subtitle"></p>
      <div class="controls" id="controls"></div>
      <div id="scatter" class="plot"></div>
      <div class="controls" id="summary_controls"></div>
      <div id="summary" class="plot" style="height:420px"></div>
    </div>
    <script>
      const BASE_TITLE = "mCode benchmark report | benchmark=mbpp";
      const ROWS = [{"backend_name": "ollama", "benchmark": "mbpp", "max_debug_iterations": 0, "model_id": "granite4:latest", "pass_rate": 0.4, "passed": 200, "retrieval": false, "runs": 20, "samples": 1, "sec_per_solve": 13.261780000000002, "solves_per_hour": 271.456772771076, "time_ms_avg": 5304.712, "time_ms_p50": 1635.0, "time_ms_p95": 3565.099999999997, "time_ms_total": 2652356, "time_s_avg": 5.304712, "time_s_p50": 1.635, "time_s_p95": 3.565099999999997, "time_s_total": 2652.356, "timed_out": 1, "timeout_rate": 0.002, "timeout_s": 60, "total": 500}, {"backend_name": "ollama", "benchmark": "mbpp", "max_debug_iterations": 0, "model_id": "granite4:latest", "pass_rate": 0.544, "passed": 272, "retrieval": false, "runs": 20, "samples": 2, "sec_per_solve": 5.589691176470588, "solves_per_hour": 644.0427362345073, "time_ms_avg": 3040.792, "time_ms_p50": 2649.5, "time_ms_p95": 5174.299999999999, "time_ms_total": 1520396, "time_s_avg": 3.0407919999999997, "time_s_p50": 2.6495, "time_s_p95": 5.1743, "time_s_total": 1520.396, "timed_out": 1, "timeout_rate": 0.002, "timeout_s": 60, "total": 500}, {"backend_name": "ollama", "benchmark": "mbpp", "max_debug_iterations": 0, "model_id": "granite4:latest", "pass_rate": 0.598, "passed": 299, "retrieval": false, "runs": 20, "samples": 3, "sec_per_solve": 8.916889632107024, "solves_per_hour": 403.728222343079, "time_ms_avg": 5332.3, "time_ms_p50": 2144.5, "time_ms_p95": 6106.599999999995, "time_ms_total": 2666150, "time_s_avg": 5.3323, "time_s_p50": 2.1445, "time_s_p95": 6.106599999999995, "time_s_total": 2666.15, "timed_out": 0, "timeout_rate": 0.0, "timeout_s": 60, "total": 500}, {"backend_name": "ollama", "benchmark": "mbpp", "max_debug_iterations": 0, "model_id": "granite4:latest", "pass_rate": 0.402, "passed": 201, "retrieval": false, "runs": 20, "samples": 1, "sec_per_solve": 8.724144278606966, "solves_per_hour": 412.6479211064621, "time_ms_avg": 3507.106, "time_ms_p50": 1800.5, "time_ms_p95": 3742.6999999999985, "time_ms_total": 1753553, "time_s_avg": 3.5071060000000003, "time_s_p50": 1.8005, "time_s_p95": 3.7426999999999984, "time_s_total": 1753.553, "timed_out": 0, "timeout_rate": 0.0, "timeout_s": 90, "total": 500}, {"backend_name": "ollama", "benchmark": "mbpp", "max_debug_iterations": 0, "model_id": "granite4:latest", "pass_rate": 0.526, "passed": 263, "retrieval": false, "runs": 20, "samples": 2, "sec_per_solve": 14.633532319391636, "solves_per_hour": 246.01032214412493, "time_ms_avg": 7697.238, "time_ms_p50": 2194.0, "time_ms_p95": 5436.849999999997, "time_ms_total": 3848619, "time_s_avg": 7.6972380000000005, "time_s_p50": 2.194, "time_s_p95": 5.436849999999997, "time_s_total": 3848.619, "timed_out": 1, "timeout_rate": 0.002, "timeout_s": 90, "total": 500}, {"backend_name": "ollama", "benchmark": "mbpp", "max_debug_iterations": 0, "model_id": "granite4:latest", "pass_rate": 0.6078838174273858, "passed": 293, "retrieval": false, "runs": 20, "samples": 3, "sec_per_solve": 6.671563139931741, "solves_per_hour": 539.6036767534562, "time_ms_avg": 4055.5352697095436, "time_ms_p50": 2023.5, "time_ms_p95": 6160.4, "time_ms_total": 1954768, "time_s_avg": 4.0555352697095435, "time_s_p50": 2.0235, "time_s_p95": 6.160399999999999, "time_s_total": 1954.768, "timed_out": 0, "timeout_rate": 0.0, "timeout_s": 90, "total": 482}, {"backend_name": "ollama", "benchmark": "mbpp", "max_debug_iterations": 1, "model_id": "granite4:latest", "pass_rate": 0.464, "passed": 232, "retrieval": false, "runs": 20, "samples": 1, "sec_per_solve": 19.72430603448276, "solves_per_hour": 182.5159269840139, "time_ms_avg": 9152.078, "time_ms_p50": 2922.0, "time_ms_p95": 6614.449999999996, "time_ms_total": 4576039, "time_s_avg": 9.152078, "time_s_p50": 2.922, "time_s_p95": 6.614449999999996, "time_s_total": 4576.039, "timed_out": 1, "timeout_rate": 0.002, "timeout_s": 60, "total": 500}, {"backend_name": "ollama", "benchmark": "mbpp", "max_debug_iterations": 1, "model_id": "granite4:latest", "pass_rate": 0.59, "passed": 295, "retrieval": false, "runs": 20, "samples": 2, "sec_per_solve": 14.3454, "solves_per_hour": 250.95152453051153, "time_ms_avg": 8463.786, "time_ms_p50": 4701.0, "time_ms_p95": 11275.799999999997, "time_ms_total": 4231893, "time_s_avg": 8.463786, "time_s_p50": 4.701, "time_s_p95": 11.275799999999997, "time_s_total": 4231.893, "timed_out": 2, "timeout_rate": 0.004, "timeout_s": 60, "total": 500}, {"backend_name": "ollama", "benchmark": "mbpp", "max_debug_iterations": 1, "model_id": "granite4:latest", "pass_rate": 0.676, "passed": 338, "retrieval": false, "runs": 20, "samples": 3, "sec_per_solve": 11.636955621301775, "solves_per_hour": 309.3592617479866, "time_ms_avg": 7866.582, "time_ms_p50": 3505.5, "time_ms_p95": 14003.649999999998, "time_ms_total": 3933291, "time_s_avg": 7.866582, "time_s_p50": 3.5055, "time_s_p95": 14.003649999999999, "time_s_total": 3933.291, "timed_out": 0, "timeout_rate": 0.0, "timeout_s": 60, "total": 500}, {"backend_name": "ollama", "benchmark": "mbpp", "max_debug_iterations": 1, "model_id": "granite4:latest", "pass_rate": 0.466, "passed": 233, "retrieval": false, "runs": 20, "samples": 1, "sec_per_solve": 25.088085836909872, "solves_per_hour": 143.49440700269128, "time_ms_avg": 11691.048, "time_ms_p50": 3182.5, "time_ms_p95": 8227.19999999998, "time_ms_total": 5845524, "time_s_avg": 11.691048, "time_s_p50": 3.1825, "time_s_p95": 8.22719999999998, "time_s_total": 5845.524, "timed_out": 1, "timeout_rate": 0.002, "timeout_s": 90, "total": 500}, {"backend_name": "ollama", "benchmark": "mbpp", "max_debug_iterations": 1, "model_id": "granite4:latest", "pass_rate": 0.592, "passed": 296, "retrieval": false, "runs": 20, "samples": 2, "sec_per_solve": 14.340989864864865, "solves_per_hour": 251.02869703714993, "time_ms_avg": 8489.866, "time_ms_p50": 4230.5, "time_ms_p95": 13979.449999999972, "time_ms_total": 4244933, "time_s_avg": 8.489866, "time_s_p50": 4.2305, "time_s_p95": 13.979449999999972, "time_s_total": 4244.933, "timed_out": 1, "timeout_rate": 0.002, "timeout_s": 90, "total": 500}, {"backend_name": "ollama", "benchmark": "mbpp", "max_debug_iterations": 1, "model_id": "granite4:latest", "pass_rate": 0.662, "passed": 331, "retrieval": false, "runs": 20, "samples": 3, "sec_per_solve": 12.6305498489426, "solves_per_hour": 285.0232209250481, "time_ms_avg": 8361.424, "time_ms_p50": 3280.5, "time_ms_p95": 14099.249999999998, "time_ms_total": 4180712, "time_s_avg": 8.361424000000001, "time_s_p50": 3.2805, "time_s_p95": 14.099249999999998, "time_s_total": 4180.712, "timed_out": 1, "timeout_rate": 0.002, "timeout_s": 90, "total": 500}, {"backend_name": "ollama", "benchmark": "mbpp", "max_debug_iterations": 2, "model_id": "granite4:latest", "pass_rate": 0.508, "passed": 254, "retrieval": false, "runs": 20, "samples": 1, "sec_per_solve": 23.117212598425198, "solves_per_hour": 155.72811750864986, "time_ms_avg": 11743.544, "time_ms_p50": 4335.0, "time_ms_p95": 10531.25, "time_ms_total": 5871772, "time_s_avg": 11.743544, "time_s_p50": 4.335, "time_s_p95": 10.53125, "time_s_total": 5871.772, "timed_out": 1, "timeout_rate": 0.002, "timeout_s": 60, "total": 500}, {"backend_name": "ollama", "benchmark": "mbpp", "max_debug_iterations": 2, "model_id": "granite4:latest", "pass_rate": 0.612, "passed": 306, "retrieval": false, "runs": 20, "samples": 2, "sec_per_solve": 13.70283660130719, "solves_per_hour": 262.7193262785149, "time_ms_avg": 8386.136, "time_ms_p50": 4752.5, "time_ms_p95": 18523.849999999984, "time_ms_total": 4193068, "time_s_avg": 8.386136, "time_s_p50": 4.7525, "time_s_p95": 18.523849999999985, "time_s_total": 4193.068, "timed_out": 2, "timeout_rate": 0.004, "timeout_s": 60, "total": 500}, {"backend_name": "ollama", "benchmark": "mbpp", "max_debug_iterations": 2, "model_id": "granite4:latest", "pass_rate": 0.6781376518218624, "passed": 335, "retrieval": false, "runs": 20, "samples": 3, "sec_per_solve": 14.984235820895522, "solves_per_hour": 240.2524922211781, "time_ms_avg": 10161.374493927126, "time_ms_p50": 3622.0, "time_ms_p95": 22306.749999999996, "time_ms_total": 5019719, "time_s_avg": 10.161374493927125, "time_s_p50": 3.622, "time_s_p95": 22.306749999999997, "time_s_total": 5019.719, "timed_out": 0, "timeout_rate": 0.0, "timeout_s": 60, "total": 494}, {"backend_name": "ollama", "benchmark": "mbpp", "max_debug_iterations": 2, "model_id": "granite4:latest", "pass_rate": 0.522, "passed": 261, "retrieval": false, "runs": 20, "samples": 1, "sec_per_solve": 16.037375478927203, "solves_per_hour": 224.47563223361138, "time_ms_avg": 8371.51, "time_ms_p50": 3804.5, "time_ms_p95": 10082.299999999996, "time_ms_total": 4185755, "time_s_avg": 8.37151, "time_s_p50": 3.8045, "time_s_p95": 10.082299999999996, "time_s_total": 4185.755, "timed_out": 2, "timeout_rate": 0.004, "timeout_s": 90, "total": 500}, {"backend_name": "ollama", "benchmark": "mbpp", "max_debug_iterations": 2, "model_id": "granite4:latest", "pass_rate": 0.628, "passed": 314, "retrieval": false, "runs": 20, "samples": 2, "sec_per_solve": 19.526799363057325, "solves_per_hour": 184.36201105291357, "time_ms_avg": 12262.83, "time_ms_p50": 4219.5, "time_ms_p95": 19324.549999999996, "time_ms_total": 6131415, "time_s_avg": 12.26283, "time_s_p50": 4.2195, "time_s_p95": 19.324549999999995, "time_s_total": 6131.415, "timed_out": 3, "timeout_rate": 0.006, "timeout_s": 90, "total": 500}, {"backend_name": "ollama", "benchmark": "mbpp", "max_debug_iterations": 2, "model_id": "granite4:latest", "pass_rate": 0.668, "passed": 334, "retrieval": false, "runs": 20, "samples": 3, "sec_per_solve": 13.396535928143713, "solves_per_hour": 268.7261855833229, "time_ms_avg": 8948.886, "time_ms_p50": 3911.0, "time_ms_p95": 20106.6, "time_ms_total": 4474443, "time_s_avg": 8.948886, "time_s_p50": 3.911, "time_s_p95": 20.1066, "time_s_total": 4474.443, "timed_out": 0, "timeout_rate": 0.0, "timeout_s": 90, "total": 500}];

      function showError(msg) {
        const p = document.createElement("p");
        p.style.margin = "10px 0 0";
        p.style.color = "#b91c1c";
        p.style.fontSize = "13px";
        p.textContent = "Report error: " + msg;
        const anchor = document.getElementById("scatter");
        if (anchor && anchor.parentElement) {
          anchor.parentElement.insertBefore(p, anchor);
        } else {
          document.body.appendChild(p);
        }
      }

      window.addEventListener("error", (e) => {
        if (e && e.message) showError(e.message);
      });
      window.addEventListener("unhandledrejection", (e) => {
        const reason = (e && e.reason) ? String(e.reason) : "unhandled promise rejection";
        showError(reason);
      });

      if (typeof Plotly === "undefined") {
        const plotlyLoadMsg =
          "Plotly failed to load. If you're offline or the CDN is blocked, " +
          "the graphs won't render.";
        showError(plotlyLoadMsg);
      }

      const CONTROLS = document.getElementById("controls");
      const SUMMARY_CONTROLS = document.getElementById("summary_controls");

        function uniqVals(rs, field) {
          const s = new Set();
          for (const r of rs) {
            const v = r[field];
            if (v === undefined || v === null) continue;
            s.add(JSON.stringify(v));
          }
          return Array.from(s).map(x => JSON.parse(x));
        }

        function constantValue(rs, field) {
          const u = uniqVals(rs, field);
          return (u.length === 1) ? u[0] : null;
        }

      function fmtBool(v) {
        return v ? "on" : "off";
      }

      function fmtTimeout(v) {
        return `${v}s`;
      }

      function valueKey(v) {
        return JSON.stringify(v);
      }

      const points = ROWS.filter(r => r.sec_per_solve !== null && r.sec_per_solve !== undefined);
      const dropped = ROWS.length - points.length;

      // Promote constants into the title, and omit them from per-point labels.
      let finalTitle = BASE_TITLE;
      const fixed = {
        benchmark: constantValue(points, "benchmark"),
        backend: constantValue(points, "backend_name"),
        model: constantValue(points, "model_id"),
        retrieval: constantValue(points, "retrieval"),
      };
      function maybeAppendTitle(k, v) {
        if (v === null || v === undefined) return;
        const needle = `${k}=`;
        if (finalTitle.includes(needle)) return;
        finalTitle += ` | ${k}=${v}`;
      }
      maybeAppendTitle("benchmark", fixed.benchmark);
      maybeAppendTitle("backend", fixed.backend);
      maybeAppendTitle("model", fixed.model);
      if (fixed.retrieval !== null) maybeAppendTitle("retrieval", fmtBool(fixed.retrieval));

      document.getElementById("title").textContent = finalTitle;
      const fixedTokens = [];
      const fixedSamples = constantValue(points, "samples");
      const fixedDebug = constantValue(points, "max_debug_iterations");
      const fixedTimeout = constantValue(points, "timeout_s");
      if (fixedSamples !== null && fixedSamples !== undefined) {
        fixedTokens.push(`s=${fixedSamples}`);
      }
      if (fixedDebug !== null && fixedDebug !== undefined) fixedTokens.push(`d=${fixedDebug}`);
      if (fixedTimeout !== null && fixedTimeout !== undefined) {
        fixedTokens.push(`t=${fixedTimeout}s`);
      }

      const droppedText = dropped ? ` (hidden: ${dropped} with 0 solves)` : "";
      let subtitle = `Plotting ${points.length} configs` + droppedText;
      subtitle += ". X = seconds/solve (lower is better). Y = pass rate (higher is better).";
      if (fixedTokens.length) subtitle += ` Fixed: ${fixedTokens.join(" ")}.`;
      document.getElementById("subtitle").textContent = subtitle;

      const CONFIG_FIELDS = [
        ["benchmark", "Benchmark"],
        ["backend_name", "Backend"],
        ["model_id", "Model"],
        ["samples", "Samples"],
        ["max_debug_iterations", "Debug"],
        ["timeout_s", "Timeout"],
        ["retrieval", "Retrieval"],
      ];

      const varying = new Map();
      for (const [f] of CONFIG_FIELDS) {
        varying.set(f, uniqVals(points, f).length > 1);
      }

      function fmtValue(field, v) {
        if (field === "retrieval") return fmtBool(!!v);
        if (field === "timeout_s") return fmtTimeout(v);
        return String(v);
      }

      function shortToken(field, v) {
        if (field === "samples") return `s=${v}`;
        if (field === "max_debug_iterations") return `d=${v}`;
        if (field === "timeout_s") return `t=${v}s`;
        if (field === "retrieval") return `r=${fmtBool(!!v)}`;
        if (field === "benchmark") return String(v);
        if (field === "backend_name") return `backend=${v}`;
        if (field === "model_id") return `model=${v}`;
        return `${field}=${v}`;
      }

      function label(r) {
        const parts = [];
        if (r.run_id !== undefined && r.run_id !== null) parts.push(`run=${r.run_id}`);
        for (const [f] of CONFIG_FIELDS) {
          if (!varying.get(f)) continue;
          const v = r[f];
          if (v === undefined || v === null) continue;
          parts.push(shortToken(f, v));
        }
        if (r.runs !== undefined && r.runs !== null && r.runs > 0) parts.push(`runs=${r.runs}`);
        return parts.join(" ");
      }

        function paretoFrontier(rs) {
          // Maximize pass_rate, minimize sec_per_solve.
          const pts = rs
            .filter(r => r.sec_per_solve !== null && r.sec_per_solve !== undefined)
            .filter(r => r.pass_rate !== null && r.pass_rate !== undefined)
            .map(r => ({ r, x: Number(r.sec_per_solve), y: Number(r.pass_rate) }))
            .filter(p => Number.isFinite(p.x) && Number.isFinite(p.y))
            // Sort by x asc, then y desc. Keep strictly improving y as x increases.
            .sort((a, b) => (a.x - b.x) || (b.y - a.y));

          const out = [];
          let bestY = -Infinity;
          for (const p of pts) {
            if (p.y > bestY) {
              out.push(p);
              bestY = p.y;
            }
          }
          return out;
        }

      const PALETTE = ["#2563eb", "#dc2626", "#16a34a", "#7c3aed", "#ea580c", "#0891b2", "#6b7280"];
      const COLOR_PRIORITY = [
        "samples",
        "max_debug_iterations",
        "timeout_s",
        "retrieval",
        "benchmark",
        "model_id",
        "backend_name",
      ];

        function buildSelect(id, labelText, options, initial) {
          const wrap = document.createElement("label");
          wrap.htmlFor = id;
          wrap.textContent = labelText;
          const sel = document.createElement("select");
        sel.id = id;
        for (const [value, text] of options) {
          const opt = document.createElement("option");
          opt.value = value;
          opt.textContent = text;
          if (value === initial) opt.selected = true;
          sel.appendChild(opt);
        }
          wrap.appendChild(sel);
          return sel;
        }

        function buildCheckbox(id, labelText, initial) {
          const wrap = document.createElement("label");
          const cb = document.createElement("input");
          cb.type = "checkbox";
          cb.id = id;
          cb.checked = !!initial;
          wrap.appendChild(cb);
          const span = document.createElement("span");
          span.textContent = labelText;
          wrap.appendChild(span);
          return cb;
        }

        function buildMultiSelectDropdown(field, labelText, values) {
          const wrap = document.createElement("details");
          wrap.className = "dd";

          const summary = document.createElement("summary");
          summary.className = "dd-btn";

          const menu = document.createElement("div");
          menu.className = "dd-menu";

          const actions = document.createElement("div");
          actions.className = "dd-actions";
          const allBtn = document.createElement("button");
          allBtn.type = "button";
          allBtn.className = "dd-action";
          allBtn.textContent = "All";
          const noneBtn = document.createElement("button");
          noneBtn.type = "button";
          noneBtn.className = "dd-action";
          noneBtn.textContent = "None";
          actions.appendChild(allBtn);
          actions.appendChild(noneBtn);

          const items = document.createElement("div");
          items.className = "dd-items";

          const checkboxes = [];
          for (const v of values) {
            const lab = document.createElement("label");
            lab.className = "dd-item";
            const cb = document.createElement("input");
            cb.type = "checkbox";
            cb.checked = true;
            cb.dataset.field = field;
            cb.dataset.key = valueKey(v);
            lab.appendChild(cb);
            const span = document.createElement("span");
            span.textContent = fmtValue(field, v);
            lab.appendChild(span);
            items.appendChild(lab);
            checkboxes.push(cb);
          }

          function update() {
            const selected = checkboxes
              .filter(cb => cb.checked)
              .map(cb => JSON.parse(cb.dataset.key));
            let summaryText = "all";
            if (selected.length === 0) summaryText = "none";
            else if (selected.length !== checkboxes.length) {
              const texts = selected.map(v => fmtValue(field, v));
              summaryText = (texts.length <= 3)
                ? texts.join(", ")
                : `${texts.length}/${checkboxes.length}`;
            }
            summary.textContent = `${labelText}: ${truncate(summaryText, 28)} ▾`;
          }

          update();

          allBtn.addEventListener("click", (e) => {
            e.preventDefault();
            for (const cb of checkboxes) cb.checked = true;
            update();
            render();
          });
          noneBtn.addEventListener("click", (e) => {
            e.preventDefault();
            for (const cb of checkboxes) cb.checked = false;
            update();
            render();
          });

          wrap.appendChild(summary);
          menu.appendChild(actions);
          menu.appendChild(items);
          wrap.appendChild(menu);

          return { wrap, checkboxes, update };
        }

      function varyingFields() {
        const out = [];
        for (const [f] of CONFIG_FIELDS) {
          if (varying.get(f)) out.push(f);
        }
        return out;
      }

        const vfields = varyingFields();

        // Filters: allow narrowing by any varying config field, while staying compact.
        const filterCheckboxes = new Map();
        const filterUpdaters = new Map();

        function sortedUnique(field) {
          const u = uniqVals(points, field);
          return u.slice().sort((a, b) => {
            const na = Number(a), nb = Number(b);
            if (!Number.isNaN(na) && !Number.isNaN(nb)) return na - nb;
            return String(a).localeCompare(String(b));
          });
        }

        function currentFilters() {
          const out = new Map();
          for (const [f, cbs] of filterCheckboxes.entries()) {
            const selected = cbs.filter(cb => cb.checked).map(cb => cb.dataset.key);
            if (selected.length === cbs.length) continue; // no-op filter
            out.set(f, new Set(selected));
          }
          return out;
        }

      function applyFilters(rs, filters) {
        if (!filters.size) return rs;
        return rs.filter(r => {
          for (const [f, set] of filters.entries()) {
            if (!set.has(valueKey(r[f]))) return false;
          }
          return true;
        });
      }

      function colorableFields() {
        const out = [];
        for (const f of vfields) {
          // Keep the legend readable.
          if (uniqVals(points, f).length <= 12) out.push(f);
        }
        return out;
      }

      const cfields = colorableFields();

      let defaultColorBy = "none";
      for (const f of COLOR_PRIORITY) {
        if (cfields.includes(f)) { defaultColorBy = f; break; }
      }

      // Controls: keep it minimal.
      const colorOptions = [["none", "none"]];
        for (const f of cfields) {
          const label = CONFIG_FIELDS.find(x => x[0] === f)?.[1] ?? f;
          colorOptions.push([f, label]);
        }
        const colorBySel = buildSelect("color_by", "Color:", colorOptions, defaultColorBy);
        const paretoCb = buildCheckbox("show_pareto", "Best tradeoffs (Pareto)", true);
        const onlyFrontierCb = buildCheckbox("only_frontier", "Only best tradeoffs", false);
        paretoCb.parentElement.title =
          "Best tradeoffs = configs where no other config is both faster and more accurate.";
        onlyFrontierCb.parentElement.title =
          "Hide configs that are dominated on both accuracy and speed.";

        CONTROLS.appendChild(colorBySel.parentElement);
        CONTROLS.appendChild(paretoCb.parentElement);
        CONTROLS.appendChild(onlyFrontierCb.parentElement);

        // Summary controls (simple + focused on accuracy/speed).
        const summarySetSel = buildSelect(
          "summary_set",
          "Summary:",
          [["frontier", "best tradeoffs"], ["shown", "all shown"]],
          "frontier",
        );
        const speedMetricSel = buildSelect(
          "speed_metric",
          "Speed:",
          [
            ["sec_per_solve", "sec/solve"],
            ["time_s_avg", "avg_s"],
            ["time_s_p95", "p95_s"],
          ],
          "sec_per_solve",
        );
        speedMetricSel.parentElement.title =
          "sec/solve = total seconds / passed tasks. avg_s = mean seconds per task. " +
          "p95_s = 95th percentile seconds per task.";
        const summaryViewSel = buildSelect(
          "summary_view",
          "View:",
          [["split", "split"], ["overlay", "overlay"]],
          "split",
        );
        const defaultTop = (points.length <= 20) ? "all" : "20";
        const topNSel = buildSelect(
          "top_n",
          "Top:",
          [["5", "5"], ["10", "10"], ["15", "15"], ["20", "20"], ["30", "30"], ["all", "all"]],
          defaultTop,
        );

        SUMMARY_CONTROLS.appendChild(summarySetSel.parentElement);
        SUMMARY_CONTROLS.appendChild(speedMetricSel.parentElement);
        SUMMARY_CONTROLS.appendChild(summaryViewSel.parentElement);
        SUMMARY_CONTROLS.appendChild(topNSel.parentElement);

        for (const f of vfields) {
          const label = CONFIG_FIELDS.find(x => x[0] === f)?.[1] ?? f;
          const u = sortedUnique(f);
          const dd = buildMultiSelectDropdown(f, label, u);
          filterCheckboxes.set(f, dd.checkboxes);
          filterUpdaters.set(f, dd.update);
          SUMMARY_CONTROLS.appendChild(dd.wrap);
        }

      function makeTraces(rs, colorBy) {
        const baseCustom = r => [
          r.total,
          r.passed,
          (r.timed_out ?? 0),
          (r.timeout_rate ?? ((r.total && r.total > 0) ? ((r.timed_out ?? 0) / r.total) : 0)),
          r.time_s_avg,
          r.time_s_p50,
          r.time_s_p95,
        ];
        const hover =
          "%{text}" +
          "<br>pass_rate=%{y:.1%}" +
          "<br>sec/solve=%{x:.2f}" +
          "<br>avg_s=%{customdata[4]:.2f}" +
          "<br>p50_s=%{customdata[5]:.2f}" +
          "<br>p95_s=%{customdata[6]:.2f}" +
          "<br>passed=%{customdata[1]}/%{customdata[0]}" +
          "<br>timed_out=%{customdata[2]}/%{customdata[0]} (%{customdata[3]:.1%})" +
          "<extra></extra>";

        if (!colorBy || colorBy === "none") {
          return [{
            type: "scatter",
            mode: "markers",
            name: "configs",
            x: rs.map(r => r.sec_per_solve),
            y: rs.map(r => r.pass_rate),
            text: rs.map(r => label(r)),
            customdata: rs.map(baseCustom),
            hovertemplate: hover,
            marker: {
              size: 10,
              opacity: 0.9,
              color: "#2563eb",
              line: { width: 1, color: "rgba(0,0,0,0.18)" },
            },
          }];
        }

        const u = uniqVals(rs, colorBy);
        const sorted = u.slice().sort((a, b) => {
          const na = Number(a), nb = Number(b);
          if (!Number.isNaN(na) && !Number.isNaN(nb)) return na - nb;
          return String(a).localeCompare(String(b));
        });
        const traces = [];
        for (let i = 0; i < sorted.length; i++) {
          const v = sorted[i];
          const sub = rs.filter(r => r[colorBy] === v);
          const colorLabel = CONFIG_FIELDS.find(x => x[0] === colorBy)?.[1] ?? colorBy;
          traces.push({
            type: "scatter",
            mode: "markers",
            name: `${colorLabel}=${fmtValue(colorBy, v)}`,
            x: sub.map(r => r.sec_per_solve),
            y: sub.map(r => r.pass_rate),
            text: sub.map(r => label(r)),
            customdata: sub.map(baseCustom),
            hovertemplate: hover,
            marker: {
              size: 10,
              opacity: 0.9,
              color: PALETTE[i % PALETTE.length],
              line: { width: 1, color: "rgba(0,0,0,0.18)" },
            },
          });
        }
        return traces;
      }

      function truncate(s, maxLen) {
        const text = String(s ?? "");
        if (text.length <= maxLen) return text;
        return text.slice(0, Math.max(0, maxLen - 1)) + "…";
      }

      function axisLabel(r) {
        const parts = [];
        if (r.run_id !== undefined && r.run_id !== null) parts.push(`run=${r.run_id}`);
        for (const [f] of CONFIG_FIELDS) {
          if (!varying.get(f)) continue;
          const v = r[f];
          if (v === undefined || v === null) continue;
          parts.push(shortToken(f, v));
        }
        return parts.join(" ");
      }

      function summaryTitle(setName, speedTitle) {
        const context = [];
        if (fixed.benchmark !== null && fixed.benchmark !== undefined) {
          context.push(String(fixed.benchmark));
        }
        if (fixed.model !== null && fixed.model !== undefined) {
          context.push(String(fixed.model));
        }
        const contextText = context.length ? ` (${context.join(" | ")})` : "";
        return `Summary${contextText} — ${setName}, speed=${speedTitle}`;
      }

        function renderSummary(rs, setName, speedField, viewMode) {
          const rows = rs
            .filter(r => r.pass_rate !== null && r.pass_rate !== undefined)
            .filter(r => r[speedField] !== null && r[speedField] !== undefined)
            .slice();

        const speedTitle =
          (speedMetricSel.options && speedMetricSel.selectedIndex >= 0)
            ? speedMetricSel.options[speedMetricSel.selectedIndex].textContent
            : speedField;

        if (rows.length === 0) {
          Plotly.react("summary", [], {
            title: summaryTitle(setName, speedTitle),
            template: "plotly_white",
          }, { displaylogo: false, responsive: true });
          return;
        }

        // Lower is better for speed metrics.
        rows.sort((a, b) => Number(a[speedField]) - Number(b[speedField]));

        const ids = rows.map((_, i) => String(i + 1));
        const ticks = rows.map(r => truncate(axisLabel(r) || "config", 64));
        const pass = rows.map(r => Number(r.pass_rate));
        const speed = rows.map(r => Number(r[speedField]));
        const details = rows.map(r => label(r));
        const totals = rows.map(r => Number(r.total ?? 0));
        const timedOut = rows.map(r => Number(r.timed_out ?? 0));
        const timeoutRates = rows.map((r, i) => {
          const fromRow = r.timeout_rate;
          if (fromRow !== undefined && fromRow !== null) return Number(fromRow);
          return totals[i] > 0 ? timedOut[i] / totals[i] : 0;
        });
        const summaryCustom = details.map((d, i) => [d, totals[i], timedOut[i], timeoutRates[i]]);

          const height = Math.max(260, Math.min(1400, 140 + rows.length * 28));
          const summaryDiv = document.getElementById("summary");
          if (summaryDiv) summaryDiv.style.height = height + "px";

          const overlay = (viewMode === "overlay");
          const passTrace = {
            type: "bar",
            orientation: "h",
            name: "pass_rate",
            x: pass,
            y: ids,
            xaxis: "x",
            marker: { color: overlay ? "rgba(37,99,235,0.70)" : "rgba(37,99,235,0.75)" },
            width: overlay ? 0.70 : undefined,
            customdata: summaryCustom,
            hovertemplate:
              "%{customdata[0]}" +
              "<br>pass_rate=%{x:.1%}" +
              "<br>timed_out=%{customdata[2]}/%{customdata[1]} (%{customdata[3]:.1%})" +
              "<extra></extra>",
          };
          const speedTrace = {
            type: "bar",
            orientation: "h",
            name: speedTitle,
            x: speed,
            y: ids,
            xaxis: "x2",
            marker: { color: overlay ? "rgba(17,24,39,0.28)" : "rgba(17,24,39,0.20)" },
            width: overlay ? 0.34 : undefined,
            customdata: summaryCustom,
            hovertemplate:
              "%{customdata[0]}" +
              "<br>" + speedTitle + "=%{x:.2f}" +
              "<br>timed_out=%{customdata[2]}/%{customdata[1]} (%{customdata[3]:.1%})" +
              "<extra></extra>",
          };

          Plotly.react("summary", [
            passTrace,
            speedTrace,
          ], {
            title: summaryTitle(setName, speedTitle),
            showlegend: false,
            barmode: "overlay",
            template: "plotly_white",
            margin: { t: overlay ? 80 : 60, r: 55, b: 30, l: 10 },
            yaxis: {
              tickvals: ids,
              ticktext: ticks,
              tickfont: { size: 11 },
              automargin: true,
              autorange: "reversed",
            },
            xaxis: {
              domain: overlay ? [0.0, 1.0] : [0.0, 0.47],
              title: "pass rate",
              tickformat: ".0%",
              range: [0, 1],
              gridcolor: "rgba(0,0,0,0.06)",
              zerolinecolor: "rgba(0,0,0,0.12)",
            },
            xaxis2: {
              domain: overlay ? [0.0, 1.0] : [0.53, 1.0],
              overlaying: overlay ? "x" : undefined,
              side: overlay ? "top" : undefined,
              title: speedTitle,
              rangemode: "tozero",
              showgrid: overlay ? false : true,
              gridcolor: "rgba(0,0,0,0.06)",
              zerolinecolor: "rgba(0,0,0,0.12)",
            },
            shapes: overlay
              ? []
              : [{
                type: "line",
                xref: "paper",
                yref: "paper",
                x0: 0.5,
                x1: 0.5,
                y0: 0,
                y1: 1,
                line: { color: "rgba(0,0,0,0.12)", width: 1 },
              }],
          }, {
            displaylogo: false,
            responsive: true,
          });
      }

        function render() {
          for (const u of filterUpdaters.values()) u();
          const colorBy = colorBySel.value;
          const filters = currentFilters();
          const base = applyFilters(points, filters);
          const frontierPts = paretoFrontier(base);
          const frontierRows = frontierPts.map(p => p.r);

        let rs = base;
        if (onlyFrontierCb.checked) {
          const fset = new Set(frontierRows);
          rs = base.filter(r => fset.has(r));
        }

        const shownTotal = rs.reduce((acc, r) => acc + Number(r.total ?? 0), 0);
        const shownTimedOut = rs.reduce((acc, r) => acc + Number(r.timed_out ?? 0), 0);
        const shownTimeoutRate = shownTotal > 0 ? shownTimedOut / shownTotal : 0;
        const shownText =
          (base.length === points.length)
            ? `Showing ${base.length} configs. `
            : `Showing ${base.length} / ${points.length} configs (filtered). `;
        const shownTimeoutPct = (shownTimeoutRate * 100).toFixed(1);
        const timeoutText =
          `Timed out: ${shownTimedOut}/${shownTotal} (${shownTimeoutPct}%). `;
        const fixedText = fixedTokens.length ? `Fixed: ${fixedTokens.join(" ")}.` : "";
        const axisHelp = "X = seconds/solve (lower is better). Y = pass rate (higher is better). ";
        document.getElementById("subtitle").textContent =
          shownText + timeoutText + axisHelp + fixedText;

          const traces = makeTraces(rs, colorBy);
          if (paretoCb.checked && frontierPts.length >= 2) {
            traces.push({
              type: "scatter",
              mode: "lines",
              name: "Best tradeoffs",
              x: frontierPts.map(p => p.x),
              y: frontierPts.map(p => p.y),
              hoverinfo: "skip",
              line: { color: "rgba(17,24,39,0.55)", width: 2, dash: "dot" },
            });
          }

          Plotly.react("scatter", traces, {
            title: "Pass rate vs seconds/solve",
            xaxis: {
              title: { text: "seconds per solve (lower is better)", standoff: 18 },
              rangemode: "tozero",
            },
            yaxis: {
              title: { text: "pass rate (higher is better)", standoff: 10 },
              tickformat: ".0%",
              rangemode: "tozero",
            },
            legend: {
              orientation: "h",
              y: -0.50,
              yanchor: "top",
              x: 0,
              xanchor: "left",
            },
            margin: { t: 60, r: 20, b: 150, l: 65 },
            template: "plotly_white",
          }, {
          displaylogo: false,
          responsive: true,
        });

          const speedField = speedMetricSel.value;
          const summarySet = summarySetSel.value;
          const viewMode = summaryViewSel.value;
          let summaryRows = (summarySet === "shown") ? rs.slice() : frontierRows.slice();
          summaryRows = summaryRows
            .filter(r => r[speedField] !== null && r[speedField] !== undefined)
            .sort((a, b) => Number(a[speedField]) - Number(b[speedField]));

        const topVal = topNSel.value;
        if (topVal !== "all") {
          const n = parseInt(topVal, 10);
          if (!Number.isNaN(n) && n > 0) summaryRows = summaryRows.slice(0, n);
        }
          const summarySetName =
            (summarySetSel.options && summarySetSel.selectedIndex >= 0)
              ? summarySetSel.options[summarySetSel.selectedIndex].textContent
              : summarySet;
          renderSummary(summaryRows, summarySetName, speedField, viewMode);
        }

      colorBySel.addEventListener("change", render);
      paretoCb.addEventListener("change", render);
      onlyFrontierCb.addEventListener("change", render);
        for (const cbs of filterCheckboxes.values()) {
          for (const cb of cbs) cb.addEventListener("change", render);
        }
        summarySetSel.addEventListener("change", render);
        speedMetricSel.addEventListener("change", render);
        summaryViewSel.addEventListener("change", render);
        topNSel.addEventListener("change", render);

      render();
    </script>
  </body>
</html>
