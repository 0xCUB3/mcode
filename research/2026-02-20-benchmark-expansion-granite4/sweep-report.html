<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>mCode benchmark report</title>
    <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
    <style>
      body {
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica,
          Arial, sans-serif;
        margin: 24px;
        background: #fff;
        color: #111827;
      }
      .container {
        max-width: 1200px;
        margin: 0 auto;
      }
      #title {
        font-size: 20px;
        font-weight: 700;
        margin: 0 0 6px;
      }
      #subtitle {
        margin: 0 0 14px;
        color: #4b5563;
        font-size: 13px;
        line-height: 1.35;
      }
      .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 10px 12px;
        align-items: center;
        margin: 10px 0 14px;
        font-size: 13px;
        color: #374151;
      }
        .controls label {
          display: inline-flex;
          gap: 6px;
          align-items: center;
        }
        details.dd {
          position: relative;
          display: inline-block;
        }
        summary.dd-btn {
          font-size: 13px;
          padding: 4px 10px;
          border: 1px solid #d1d5db;
          border-radius: 8px;
          background: #fff;
          color: #111827;
          cursor: pointer;
          list-style: none;
        }
        summary.dd-btn::-webkit-details-marker {
          display: none;
        }
        summary.dd-btn::marker {
          content: "";
        }
        summary.dd-btn:hover {
          background: #f9fafb;
        }
        details.dd > .dd-menu {
          display: none;
        }
        details.dd[open] > .dd-menu {
          display: block;
        }
        .dd-menu {
          position: absolute;
          top: calc(100% + 6px);
          left: 0;
          z-index: 1000;
          min-width: 220px;
          max-width: 320px;
          background: #fff;
          border: 1px solid #e5e7eb;
          border-radius: 12px;
          padding: 8px;
          box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
        }
        .dd-actions {
          display: flex;
          gap: 8px;
          margin-bottom: 6px;
        }
        .dd-action {
          font-size: 12px;
          padding: 2px 8px;
          border: 1px solid #e5e7eb;
          border-radius: 8px;
          background: #f9fafb;
          color: #111827;
          cursor: pointer;
        }
        .dd-action:hover {
          background: #f3f4f6;
        }
        .dd-items {
          max-height: 240px;
          overflow: auto;
        }
        label.dd-item {
          display: flex;
          gap: 8px;
          align-items: center;
          width: 100%;
          box-sizing: border-box;
          padding: 4px 6px;
          border-radius: 8px;
          cursor: pointer;
          user-select: none;
        }
        label.dd-item:hover {
          background: #f3f4f6;
        }
        .dd-item input[type="checkbox"] {
          margin: 0;
        }
      select {
        font-size: 13px;
        padding: 4px 8px;
        border: 1px solid #d1d5db;
        border-radius: 8px;
        background: #fff;
        color: #111827;
      }
      input[type="checkbox"] {
        width: 14px;
        height: 14px;
      }
      .plot {
        width: 100%;
        height: 560px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1 id="title"></h1>
      <p id="subtitle"></p>
      <div class="controls" id="controls"></div>
      <div id="scatter" class="plot"></div>
      <div class="controls" id="summary_controls"></div>
      <div id="summary" class="plot" style="height:420px"></div>
    </div>
    <script>
      const BASE_TITLE = "mCode benchmark report";
      const ROWS = [{"backend_name": "ollama", "benchmark": "bigcodebench-complete", "loop_budget": 1, "model_id": "granite4:latest", "pass_rate": 0.11764705882352941, "passed": 132, "retrieval": false, "runs": 20, "sec_per_solve": 45.30352272727272, "solves_per_hour": 79.46401920380464, "time_ms_avg": 5329.826203208556, "time_ms_p50": 5147.0, "time_ms_p95": 8331.8, "time_ms_total": 5980065, "time_s_avg": 5.3298262032085555, "time_s_p50": 5.147, "time_s_p95": 8.3318, "time_s_total": 5980.065, "timed_out": 1, "timeout_rate": 0.00089126559714795, "timeout_s": 60, "total": 1122}, {"backend_name": "ollama", "benchmark": "bigcodebench-complete", "loop_budget": 3, "model_id": "granite4:latest", "pass_rate": 0.1802841918294849, "passed": 203, "retrieval": false, "runs": 20, "sec_per_solve": 91.09299014778325, "solves_per_hour": 39.52005521126925, "time_ms_avg": 16422.626110124333, "time_ms_p50": 17383.0, "time_ms_p95": 24244.25, "time_ms_total": 18491877, "time_s_avg": 16.422626110124334, "time_s_p50": 17.383, "time_s_p95": 24.24425, "time_s_total": 18491.877, "timed_out": 0, "timeout_rate": 0.0, "timeout_s": 60, "total": 1126}, {"backend_name": "ollama", "benchmark": "bigcodebench-complete", "loop_budget": 5, "model_id": "granite4:latest", "pass_rate": 0.21758436944937834, "passed": 245, "retrieval": false, "runs": 20, "sec_per_solve": 122.56292244897959, "solves_per_hour": 29.37266775356638, "time_ms_avg": 26667.77619893428, "time_ms_p50": 29235.0, "time_ms_p95": 39750.5, "time_ms_total": 30027916, "time_s_avg": 26.66777619893428, "time_s_p50": 29.235, "time_s_p95": 39.7505, "time_s_total": 30027.916, "timed_out": 0, "timeout_rate": 0.0, "timeout_s": 60, "total": 1126}, {"backend_name": "ollama", "benchmark": "bigcodebench-complete", "loop_budget": 1, "model_id": "granite4:latest", "pass_rate": 0.12631578947368421, "passed": 144, "retrieval": false, "runs": 20, "sec_per_solve": 39.83675, "solves_per_hour": 90.36881773739073, "time_ms_avg": 5032.010526315789, "time_ms_p50": 4990.0, "time_ms_p95": 8049.1, "time_ms_total": 5736492, "time_s_avg": 5.03201052631579, "time_s_p50": 4.99, "time_s_p95": 8.049100000000001, "time_s_total": 5736.492, "timed_out": 0, "timeout_rate": 0.0, "timeout_s": 120, "total": 1140}, {"backend_name": "ollama", "benchmark": "bigcodebench-complete", "loop_budget": 3, "model_id": "granite4:latest", "pass_rate": 0.19473684210526315, "passed": 222, "retrieval": false, "runs": 20, "sec_per_solve": 81.67055855855857, "solves_per_hour": 44.07953200685858, "time_ms_avg": 15904.266666666666, "time_ms_p50": 16761.0, "time_ms_p95": 24043.1, "time_ms_total": 18130864, "time_s_avg": 15.904266666666667, "time_s_p50": 16.761, "time_s_p95": 24.0431, "time_s_total": 18130.864, "timed_out": 0, "timeout_rate": 0.0, "timeout_s": 120, "total": 1140}, {"backend_name": "ollama", "benchmark": "bigcodebench-complete", "loop_budget": 5, "model_id": "granite4:latest", "pass_rate": 0.21771523178807947, "passed": 263, "retrieval": false, "runs": 23, "sec_per_solve": 73.4459771863118, "solves_per_hour": 49.0156185255431, "time_ms_avg": 15990.307947019868, "time_ms_p50": 15036.0, "time_ms_p95": 31877.399999999983, "time_ms_total": 19316292, "time_s_avg": 15.990307947019868, "time_s_p50": 15.036, "time_s_p95": 31.877399999999984, "time_s_total": 19316.292, "timed_out": 0, "timeout_rate": 0.0, "timeout_s": 120, "total": 1208}, {"backend_name": "ollama", "benchmark": "bigcodebench-instruct", "loop_budget": 1, "model_id": "granite4:latest", "pass_rate": 0.11842105263157894, "passed": 135, "retrieval": false, "runs": 20, "sec_per_solve": 21.578244444444444, "solves_per_hour": 166.83470285400625, "time_ms_avg": 2555.3184210526315, "time_ms_p50": 2360.5, "time_ms_p95": 4255.0, "time_ms_total": 2913063, "time_s_avg": 2.5553184210526316, "time_s_p50": 2.3605, "time_s_p95": 4.255, "time_s_total": 2913.063, "timed_out": 1, "timeout_rate": 0.0008771929824561404, "timeout_s": 60, "total": 1140}, {"backend_name": "ollama", "benchmark": "bigcodebench-instruct", "loop_budget": 3, "model_id": "granite4:latest", "pass_rate": 0.18333333333333332, "passed": 209, "retrieval": false, "runs": 20, "sec_per_solve": 37.12871770334928, "solves_per_hour": 96.95998738128394, "time_ms_avg": 6806.9315789473685, "time_ms_p50": 6660.5, "time_ms_p95": 11422.499999999998, "time_ms_total": 7759902, "time_s_avg": 6.806931578947369, "time_s_p50": 6.6605, "time_s_p95": 11.422499999999998, "time_s_total": 7759.902, "timed_out": 2, "timeout_rate": 0.0017543859649122807, "timeout_s": 60, "total": 1140}, {"backend_name": "ollama", "benchmark": "bigcodebench-instruct", "loop_budget": 5, "model_id": "granite4:latest", "pass_rate": 0.2134502923976608, "passed": 146, "retrieval": false, "runs": 12, "sec_per_solve": 63.221219178082194, "solves_per_hour": 56.94290693539905, "time_ms_avg": 13494.587719298246, "time_ms_p50": 12774.5, "time_ms_p95": 19576.100000000002, "time_ms_total": 9230298, "time_s_avg": 13.494587719298247, "time_s_p50": 12.7745, "time_s_p95": 19.576100000000004, "time_s_total": 9230.298, "timed_out": 2, "timeout_rate": 0.0029239766081871343, "timeout_s": 60, "total": 684}, {"backend_name": "ollama", "benchmark": "bigcodebench-instruct", "loop_budget": 1, "model_id": "granite4:latest", "pass_rate": 0.12631578947368421, "passed": 144, "retrieval": false, "runs": 20, "sec_per_solve": 19.675069444444446, "solves_per_hour": 182.9726705750721, "time_ms_avg": 2485.2719298245615, "time_ms_p50": 2276.5, "time_ms_p95": 3909.6999999999994, "time_ms_total": 2833210, "time_s_avg": 2.4852719298245614, "time_s_p50": 2.2765, "time_s_p95": 3.9096999999999995, "time_s_total": 2833.21, "timed_out": 1, "timeout_rate": 0.0008771929824561404, "timeout_s": 120, "total": 1140}, {"backend_name": "ollama", "benchmark": "bigcodebench-instruct", "loop_budget": 3, "model_id": "granite4:latest", "pass_rate": 0.18672199170124482, "passed": 135, "retrieval": false, "runs": 13, "sec_per_solve": 39.5606962962963, "solves_per_hour": 90.99940944004655, "time_ms_avg": 7386.852005532503, "time_ms_p50": 7136.0, "time_ms_p95": 11237.599999999999, "time_ms_total": 5340694, "time_s_avg": 7.3868520055325035, "time_s_p50": 7.136, "time_s_p95": 11.237599999999999, "time_s_total": 5340.694, "timed_out": 0, "timeout_rate": 0.0, "timeout_s": 120, "total": 723}, {"backend_name": "ollama", "benchmark": "humaneval+", "loop_budget": 1, "model_id": "granite4:latest", "pass_rate": 0.6463414634146342, "passed": 106, "retrieval": false, "runs": 20, "sec_per_solve": 1.8114433962264151, "solves_per_hour": 1987.3654387984147, "time_ms_avg": 1170.810975609756, "time_ms_p50": 1006.0, "time_ms_p95": 2548.5, "time_ms_total": 192013, "time_s_avg": 1.170810975609756, "time_s_p50": 1.006, "time_s_p95": 2.5485, "time_s_total": 192.013, "timed_out": 0, "timeout_rate": 0.0, "timeout_s": 60, "total": 164}, {"backend_name": "ollama", "benchmark": "humaneval+", "loop_budget": 3, "model_id": "granite4:latest", "pass_rate": 0.7865853658536586, "passed": 129, "retrieval": false, "runs": 20, "sec_per_solve": 4.341790697674418, "solves_per_hour": 829.1509772519108, "time_ms_avg": 3415.189024390244, "time_ms_p50": 1805.5, "time_ms_p95": 6210.949999999999, "time_ms_total": 560091, "time_s_avg": 3.415189024390244, "time_s_p50": 1.8055, "time_s_p95": 6.210949999999999, "time_s_total": 560.091, "timed_out": 0, "timeout_rate": 0.0, "timeout_s": 60, "total": 164}, {"backend_name": "ollama", "benchmark": "humaneval+", "loop_budget": 5, "model_id": "granite4:latest", "pass_rate": 0.8475609756097561, "passed": 139, "retrieval": false, "runs": 20, "sec_per_solve": 6.479625899280576, "solves_per_hour": 555.5876305142406, "time_ms_avg": 5491.878048780488, "time_ms_p50": 3469.5, "time_ms_p95": 13965.9, "time_ms_total": 900668, "time_s_avg": 5.491878048780488, "time_s_p50": 3.4695, "time_s_p95": 13.9659, "time_s_total": 900.668, "timed_out": 0, "timeout_rate": 0.0, "timeout_s": 60, "total": 164}, {"backend_name": "ollama", "benchmark": "humaneval+", "loop_budget": 1, "model_id": "granite4:latest", "pass_rate": 0.676829268292683, "passed": 111, "retrieval": false, "runs": 20, "sec_per_solve": 1.968144144144144, "solves_per_hour": 1829.1343196133002, "time_ms_avg": 1332.0975609756097, "time_ms_p50": 1036.0, "time_ms_p95": 3690.9499999999985, "time_ms_total": 218464, "time_s_avg": 1.3320975609756096, "time_s_p50": 1.036, "time_s_p95": 3.6909499999999986, "time_s_total": 218.464, "timed_out": 0, "timeout_rate": 0.0, "timeout_s": 120, "total": 164}, {"backend_name": "ollama", "benchmark": "humaneval+", "loop_budget": 3, "model_id": "granite4:latest", "pass_rate": 0.8109756097560976, "passed": 133, "retrieval": false, "runs": 20, "sec_per_solve": 3.3896766917293233, "solves_per_hour": 1062.048191434852, "time_ms_avg": 2748.9451219512193, "time_ms_p50": 2046.0, "time_ms_p95": 7819.049999999999, "time_ms_total": 450827, "time_s_avg": 2.7489451219512193, "time_s_p50": 2.046, "time_s_p95": 7.819049999999999, "time_s_total": 450.827, "timed_out": 0, "timeout_rate": 0.0, "timeout_s": 120, "total": 164}, {"backend_name": "ollama", "benchmark": "humaneval+", "loop_budget": 5, "model_id": "granite4:latest", "pass_rate": 0.8414634146341463, "passed": 138, "retrieval": false, "runs": 20, "sec_per_solve": 6.234782608695652, "solves_per_hour": 577.4058577405858, "time_ms_avg": 5246.341463414634, "time_ms_p50": 3297.0, "time_ms_p95": 15429.0, "time_ms_total": 860400, "time_s_avg": 5.246341463414634, "time_s_p50": 3.297, "time_s_p95": 15.429, "time_s_total": 860.4, "timed_out": 0, "timeout_rate": 0.0, "timeout_s": 120, "total": 164}, {"backend_name": "ollama", "benchmark": "livecodebench", "loop_budget": 1, "model_id": "granite4:latest", "pass_rate": 0.003913894324853229, "passed": 2, "retrieval": false, "runs": 20, "sec_per_solve": 524.0455, "solves_per_hour": 6.869632503284544, "time_ms_avg": 2051.058708414873, "time_ms_p50": 1829.0, "time_ms_p95": 4223.0, "time_ms_total": 1048091, "time_s_avg": 2.051058708414873, "time_s_p50": 1.829, "time_s_p95": 4.223, "time_s_total": 1048.091, "timed_out": 0, "timeout_rate": 0.0, "timeout_s": 60, "total": 511}, {"backend_name": "ollama", "benchmark": "livecodebench", "loop_budget": 3, "model_id": "granite4:latest", "pass_rate": 0.019569471624266144, "passed": 10, "retrieval": false, "runs": 20, "sec_per_solve": 260.1904, "solves_per_hour": 13.836021621089786, "time_ms_avg": 5091.788649706458, "time_ms_p50": 4543.0, "time_ms_p95": 9582.5, "time_ms_total": 2601904, "time_s_avg": 5.091788649706459, "time_s_p50": 4.543, "time_s_p95": 9.5825, "time_s_total": 2601.904, "timed_out": 0, "timeout_rate": 0.0, "timeout_s": 60, "total": 511}, {"backend_name": "ollama", "benchmark": "livecodebench", "loop_budget": 5, "model_id": "granite4:latest", "pass_rate": 0.0273972602739726, "passed": 14, "retrieval": false, "runs": 20, "sec_per_solve": 527.1607857142857, "solves_per_hour": 6.829036031430367, "time_ms_avg": 14442.761252446184, "time_ms_p50": 13781.0, "time_ms_p95": 23275.0, "time_ms_total": 7380251, "time_s_avg": 14.442761252446184, "time_s_p50": 13.781, "time_s_p95": 23.275, "time_s_total": 7380.251, "timed_out": 0, "timeout_rate": 0.0, "timeout_s": 60, "total": 511}, {"backend_name": "ollama", "benchmark": "livecodebench", "loop_budget": 1, "model_id": "granite4:latest", "pass_rate": 0.005870841487279843, "passed": 3, "retrieval": false, "runs": 20, "sec_per_solve": 384.57199999999995, "solves_per_hour": 9.361055927108579, "time_ms_avg": 2257.761252446184, "time_ms_p50": 2043.0, "time_ms_p95": 4644.5, "time_ms_total": 1153716, "time_s_avg": 2.257761252446184, "time_s_p50": 2.043, "time_s_p95": 4.6445, "time_s_total": 1153.716, "timed_out": 0, "timeout_rate": 0.0, "timeout_s": 120, "total": 511}, {"backend_name": "ollama", "benchmark": "livecodebench", "loop_budget": 3, "model_id": "granite4:latest", "pass_rate": 0.019569471624266144, "passed": 10, "retrieval": false, "runs": 20, "sec_per_solve": 391.0261, "solves_per_hour": 9.206546570676485, "time_ms_avg": 7652.174168297456, "time_ms_p50": 7370.0, "time_ms_p95": 13737.5, "time_ms_total": 3910261, "time_s_avg": 7.6521741682974564, "time_s_p50": 7.37, "time_s_p95": 13.7375, "time_s_total": 3910.261, "timed_out": 0, "timeout_rate": 0.0, "timeout_s": 120, "total": 511}, {"backend_name": "ollama", "benchmark": "livecodebench", "loop_budget": 5, "model_id": "granite4:latest", "pass_rate": 0.02982107355864811, "passed": 15, "retrieval": false, "runs": 20, "sec_per_solve": 520.6970666666667, "solves_per_hour": 6.913808873643229, "time_ms_avg": 15527.745526838966, "time_ms_p50": 14433.0, "time_ms_p95": 25118.8, "time_ms_total": 7810456, "time_s_avg": 15.527745526838967, "time_s_p50": 14.433, "time_s_p95": 25.1188, "time_s_total": 7810.456, "timed_out": 0, "timeout_rate": 0.0, "timeout_s": 120, "total": 503}, {"backend_name": "ollama", "benchmark": "mbpp+", "loop_budget": 1, "model_id": "granite4:latest", "pass_rate": 0.9021164021164021, "passed": 341, "retrieval": false, "runs": 20, "sec_per_solve": 0.8930381231671555, "solves_per_hour": 4031.182887503858, "time_ms_avg": 805.6243386243386, "time_ms_p50": 729.5, "time_ms_p95": 1532.1999999999998, "time_ms_total": 304526, "time_s_avg": 0.8056243386243387, "time_s_p50": 0.7295, "time_s_p95": 1.5321999999999998, "time_s_total": 304.526, "timed_out": 0, "timeout_rate": 0.0, "timeout_s": 60, "total": 378}, {"backend_name": "ollama", "benchmark": "mbpp+", "loop_budget": 3, "model_id": "granite4:latest", "pass_rate": 0.9708994708994709, "passed": 367, "retrieval": false, "runs": 20, "sec_per_solve": 1.0236103542234334, "solves_per_hour": 3516.963251833415, "time_ms_avg": 993.8227513227513, "time_ms_p50": 783.5, "time_ms_p95": 2608.8999999999987, "time_ms_total": 375665, "time_s_avg": 0.9938227513227513, "time_s_p50": 0.7835, "time_s_p95": 2.608899999999999, "time_s_total": 375.665, "timed_out": 0, "timeout_rate": 0.0, "timeout_s": 60, "total": 378}, {"backend_name": "ollama", "benchmark": "mbpp+", "loop_budget": 5, "model_id": "granite4:latest", "pass_rate": 0.9814814814814815, "passed": 371, "retrieval": false, "runs": 20, "sec_per_solve": 1.0689838274932615, "solves_per_hour": 3367.684250604524, "time_ms_avg": 1049.1878306878307, "time_ms_p50": 813.0, "time_ms_p95": 2862.1999999999975, "time_ms_total": 396593, "time_s_avg": 1.0491878306878306, "time_s_p50": 0.813, "time_s_p95": 2.8621999999999974, "time_s_total": 396.593, "timed_out": 0, "timeout_rate": 0.0, "timeout_s": 60, "total": 378}, {"backend_name": "ollama", "benchmark": "mbpp+", "loop_budget": 1, "model_id": "granite4:latest", "pass_rate": 0.8677248677248677, "passed": 328, "retrieval": false, "runs": 20, "sec_per_solve": 0.9186371951219512, "solves_per_hour": 3918.848506370452, "time_ms_avg": 797.1243386243386, "time_ms_p50": 749.0, "time_ms_p95": 1498.9499999999998, "time_ms_total": 301313, "time_s_avg": 0.7971243386243386, "time_s_p50": 0.749, "time_s_p95": 1.4989499999999998, "time_s_total": 301.313, "timed_out": 0, "timeout_rate": 0.0, "timeout_s": 120, "total": 378}, {"backend_name": "ollama", "benchmark": "mbpp+", "loop_budget": 3, "model_id": "granite4:latest", "pass_rate": 0.9656084656084656, "passed": 365, "retrieval": false, "runs": 20, "sec_per_solve": 0.9548986301369863, "solves_per_hour": 3770.033683558177, "time_ms_avg": 922.058201058201, "time_ms_p50": 754.0, "time_ms_p95": 2111.4499999999994, "time_ms_total": 348538, "time_s_avg": 0.922058201058201, "time_s_p50": 0.754, "time_s_p95": 2.111449999999999, "time_s_total": 348.538, "timed_out": 0, "timeout_rate": 0.0, "timeout_s": 120, "total": 378}, {"backend_name": "ollama", "benchmark": "mbpp+", "loop_budget": 5, "model_id": "granite4:latest", "pass_rate": 0.9841269841269841, "passed": 372, "retrieval": false, "runs": 20, "sec_per_solve": 1.11377688172043, "solves_per_hour": 3232.2452181258673, "time_ms_avg": 1096.0978835978835, "time_ms_p50": 826.5, "time_ms_p95": 2619.1999999999985, "time_ms_total": 414325, "time_s_avg": 1.0960978835978836, "time_s_p50": 0.8265, "time_s_p95": 2.6191999999999984, "time_s_total": 414.325, "timed_out": 0, "timeout_rate": 0.0, "timeout_s": 120, "total": 378}];

      function showError(msg) {
        const p = document.createElement("p");
        p.style.margin = "10px 0 0";
        p.style.color = "#b91c1c";
        p.style.fontSize = "13px";
        p.textContent = "Report error: " + msg;
        const anchor = document.getElementById("scatter");
        if (anchor && anchor.parentElement) {
          anchor.parentElement.insertBefore(p, anchor);
        } else {
          document.body.appendChild(p);
        }
      }

      window.addEventListener("error", (e) => {
        if (e && e.message) showError(e.message);
      });
      window.addEventListener("unhandledrejection", (e) => {
        const reason = (e && e.reason) ? String(e.reason) : "unhandled promise rejection";
        showError(reason);
      });

      if (typeof Plotly === "undefined") {
        const plotlyLoadMsg =
          "Plotly failed to load. If you're offline or the CDN is blocked, " +
          "the graphs won't render.";
        showError(plotlyLoadMsg);
      }

      const CONTROLS = document.getElementById("controls");
      const SUMMARY_CONTROLS = document.getElementById("summary_controls");

        function uniqVals(rs, field) {
          const s = new Set();
          for (const r of rs) {
            const v = r[field];
            if (v === undefined || v === null) continue;
            s.add(JSON.stringify(v));
          }
          return Array.from(s).map(x => JSON.parse(x));
        }

        function constantValue(rs, field) {
          const u = uniqVals(rs, field);
          return (u.length === 1) ? u[0] : null;
        }

      function fmtBool(v) {
        return v ? "on" : "off";
      }

      function fmtTimeout(v) {
        return `${v}s`;
      }

      function valueKey(v) {
        return JSON.stringify(v);
      }

      const points = ROWS.filter(r => r.sec_per_solve !== null && r.sec_per_solve !== undefined);
      const dropped = ROWS.length - points.length;

      // Promote constants into the title, and omit them from per-point labels.
      let finalTitle = BASE_TITLE;
      const fixed = {
        benchmark: constantValue(points, "benchmark"),
        backend: constantValue(points, "backend_name"),
        model: constantValue(points, "model_id"),
        retrieval: constantValue(points, "retrieval"),
      };
      function maybeAppendTitle(k, v) {
        if (v === null || v === undefined) return;
        const needle = `${k}=`;
        if (finalTitle.includes(needle)) return;
        finalTitle += ` | ${k}=${v}`;
      }
      maybeAppendTitle("benchmark", fixed.benchmark);
      maybeAppendTitle("backend", fixed.backend);
      maybeAppendTitle("model", fixed.model);
      if (fixed.retrieval !== null) maybeAppendTitle("retrieval", fmtBool(fixed.retrieval));

      document.getElementById("title").textContent = finalTitle;
      const fixedTokens = [];
      const fixedBudget = constantValue(points, "loop_budget");
      const fixedTimeout = constantValue(points, "timeout_s");
      if (fixedBudget !== null && fixedBudget !== undefined) {
        fixedTokens.push(`budget=${fixedBudget}`);
      }
      if (fixedTimeout !== null && fixedTimeout !== undefined) {
        fixedTokens.push(`t=${fixedTimeout}s`);
      }

      const droppedText = dropped ? ` (hidden: ${dropped} with 0 solves)` : "";
      let subtitle = `Plotting ${points.length} configs` + droppedText;
      subtitle += ". X = seconds/solve (lower is better). Y = pass rate (higher is better).";
      if (fixedTokens.length) subtitle += ` Fixed: ${fixedTokens.join(" ")}.`;
      document.getElementById("subtitle").textContent = subtitle;

      const CONFIG_FIELDS = [
        ["benchmark", "Benchmark"],
        ["backend_name", "Backend"],
        ["model_id", "Model"],
        ["loop_budget", "Budget"],
        ["timeout_s", "Timeout"],
        ["retrieval", "Retrieval"],
      ];

      const varying = new Map();
      for (const [f] of CONFIG_FIELDS) {
        varying.set(f, uniqVals(points, f).length > 1);
      }

      function fmtValue(field, v) {
        if (field === "retrieval") return fmtBool(!!v);
        if (field === "timeout_s") return fmtTimeout(v);
        return String(v);
      }

      function shortToken(field, v) {
        if (field === "loop_budget") return `budget=${v}`;
        if (field === "timeout_s") return `t=${v}s`;
        if (field === "retrieval") return `r=${fmtBool(!!v)}`;
        if (field === "benchmark") return String(v);
        if (field === "backend_name") return `backend=${v}`;
        if (field === "model_id") return `model=${v}`;
        return `${field}=${v}`;
      }

      function label(r) {
        const parts = [];
        if (r.run_id !== undefined && r.run_id !== null) parts.push(`run=${r.run_id}`);
        for (const [f] of CONFIG_FIELDS) {
          if (!varying.get(f)) continue;
          const v = r[f];
          if (v === undefined || v === null) continue;
          parts.push(shortToken(f, v));
        }
        if (r.runs !== undefined && r.runs !== null && r.runs > 0) parts.push(`runs=${r.runs}`);
        return parts.join(" ");
      }

        function paretoFrontier(rs) {
          // Maximize pass_rate, minimize sec_per_solve.
          const pts = rs
            .filter(r => r.sec_per_solve !== null && r.sec_per_solve !== undefined)
            .filter(r => r.pass_rate !== null && r.pass_rate !== undefined)
            .map(r => ({ r, x: Number(r.sec_per_solve), y: Number(r.pass_rate) }))
            .filter(p => Number.isFinite(p.x) && Number.isFinite(p.y))
            // Sort by x asc, then y desc. Keep strictly improving y as x increases.
            .sort((a, b) => (a.x - b.x) || (b.y - a.y));

          const out = [];
          let bestY = -Infinity;
          for (const p of pts) {
            if (p.y > bestY) {
              out.push(p);
              bestY = p.y;
            }
          }
          return out;
        }

      const PALETTE = ["#2563eb", "#dc2626", "#16a34a", "#7c3aed", "#ea580c", "#0891b2", "#6b7280"];
      const COLOR_PRIORITY = [
        "benchmark",
        "loop_budget",
        "timeout_s",
        "retrieval",
        "model_id",
        "backend_name",
      ];

        function buildSelect(id, labelText, options, initial) {
          const wrap = document.createElement("label");
          wrap.htmlFor = id;
          wrap.textContent = labelText;
          const sel = document.createElement("select");
        sel.id = id;
        for (const [value, text] of options) {
          const opt = document.createElement("option");
          opt.value = value;
          opt.textContent = text;
          if (value === initial) opt.selected = true;
          sel.appendChild(opt);
        }
          wrap.appendChild(sel);
          return sel;
        }

        function buildCheckbox(id, labelText, initial) {
          const wrap = document.createElement("label");
          const cb = document.createElement("input");
          cb.type = "checkbox";
          cb.id = id;
          cb.checked = !!initial;
          wrap.appendChild(cb);
          const span = document.createElement("span");
          span.textContent = labelText;
          wrap.appendChild(span);
          return cb;
        }

        function buildMultiSelectDropdown(field, labelText, values) {
          const wrap = document.createElement("details");
          wrap.className = "dd";

          const summary = document.createElement("summary");
          summary.className = "dd-btn";

          const menu = document.createElement("div");
          menu.className = "dd-menu";

          const actions = document.createElement("div");
          actions.className = "dd-actions";
          const allBtn = document.createElement("button");
          allBtn.type = "button";
          allBtn.className = "dd-action";
          allBtn.textContent = "All";
          const noneBtn = document.createElement("button");
          noneBtn.type = "button";
          noneBtn.className = "dd-action";
          noneBtn.textContent = "None";
          actions.appendChild(allBtn);
          actions.appendChild(noneBtn);

          const items = document.createElement("div");
          items.className = "dd-items";

          const checkboxes = [];
          for (const v of values) {
            const lab = document.createElement("label");
            lab.className = "dd-item";
            const cb = document.createElement("input");
            cb.type = "checkbox";
            cb.checked = true;
            cb.dataset.field = field;
            cb.dataset.key = valueKey(v);
            lab.appendChild(cb);
            const span = document.createElement("span");
            span.textContent = fmtValue(field, v);
            lab.appendChild(span);
            items.appendChild(lab);
            checkboxes.push(cb);
          }

          function update() {
            const selected = checkboxes
              .filter(cb => cb.checked)
              .map(cb => JSON.parse(cb.dataset.key));
            let summaryText = "all";
            if (selected.length === 0) summaryText = "none";
            else if (selected.length !== checkboxes.length) {
              const texts = selected.map(v => fmtValue(field, v));
              summaryText = (texts.length <= 3)
                ? texts.join(", ")
                : `${texts.length}/${checkboxes.length}`;
            }
            summary.textContent = `${labelText}: ${truncate(summaryText, 28)} ▾`;
          }

          update();

          allBtn.addEventListener("click", (e) => {
            e.preventDefault();
            for (const cb of checkboxes) cb.checked = true;
            update();
            render();
          });
          noneBtn.addEventListener("click", (e) => {
            e.preventDefault();
            for (const cb of checkboxes) cb.checked = false;
            update();
            render();
          });

          wrap.appendChild(summary);
          menu.appendChild(actions);
          menu.appendChild(items);
          wrap.appendChild(menu);

          return { wrap, checkboxes, update };
        }

      function varyingFields() {
        const out = [];
        for (const [f] of CONFIG_FIELDS) {
          if (varying.get(f)) out.push(f);
        }
        return out;
      }

        const vfields = varyingFields();

        // Filters: allow narrowing by any varying config field, while staying compact.
        const filterCheckboxes = new Map();
        const filterUpdaters = new Map();

        function sortedUnique(field) {
          const u = uniqVals(points, field);
          return u.slice().sort((a, b) => {
            const na = Number(a), nb = Number(b);
            if (!Number.isNaN(na) && !Number.isNaN(nb)) return na - nb;
            return String(a).localeCompare(String(b));
          });
        }

        function currentFilters() {
          const out = new Map();
          for (const [f, cbs] of filterCheckboxes.entries()) {
            const selected = cbs.filter(cb => cb.checked).map(cb => cb.dataset.key);
            if (selected.length === cbs.length) continue; // no-op filter
            out.set(f, new Set(selected));
          }
          return out;
        }

      function applyFilters(rs, filters) {
        if (!filters.size) return rs;
        return rs.filter(r => {
          for (const [f, set] of filters.entries()) {
            if (!set.has(valueKey(r[f]))) return false;
          }
          return true;
        });
      }

      function colorableFields() {
        const out = [];
        for (const f of vfields) {
          // Keep the legend readable.
          if (uniqVals(points, f).length <= 12) out.push(f);
        }
        return out;
      }

      const cfields = colorableFields();

      let defaultColorBy = "none";
      for (const f of COLOR_PRIORITY) {
        if (cfields.includes(f)) { defaultColorBy = f; break; }
      }

      // Controls: keep it minimal.
      const colorOptions = [["none", "none"]];
        for (const f of cfields) {
          const label = CONFIG_FIELDS.find(x => x[0] === f)?.[1] ?? f;
          colorOptions.push([f, label]);
        }
        const colorBySel = buildSelect("color_by", "Color:", colorOptions, defaultColorBy);
        const paretoCb = buildCheckbox("show_pareto", "Best tradeoffs (Pareto)", true);
        const onlyFrontierCb = buildCheckbox("only_frontier", "Only best tradeoffs", false);
        paretoCb.parentElement.title =
          "Best tradeoffs = configs where no other config is both faster and more accurate.";
        onlyFrontierCb.parentElement.title =
          "Hide configs that are dominated on both accuracy and speed.";

        CONTROLS.appendChild(colorBySel.parentElement);
        CONTROLS.appendChild(paretoCb.parentElement);
        CONTROLS.appendChild(onlyFrontierCb.parentElement);

        // Summary controls (simple + focused on accuracy/speed).
        const summarySetSel = buildSelect(
          "summary_set",
          "Summary:",
          [["frontier", "best tradeoffs"], ["shown", "all shown"]],
          "frontier",
        );
        const speedMetricSel = buildSelect(
          "speed_metric",
          "Speed:",
          [
            ["sec_per_solve", "sec/solve"],
            ["time_s_avg", "avg_s"],
            ["time_s_p95", "p95_s"],
          ],
          "sec_per_solve",
        );
        speedMetricSel.parentElement.title =
          "sec/solve = total seconds / passed tasks. avg_s = mean seconds per task. " +
          "p95_s = 95th percentile seconds per task.";
        const summaryViewSel = buildSelect(
          "summary_view",
          "View:",
          [["split", "split"], ["overlay", "overlay"]],
          "split",
        );
        const defaultTop = (points.length <= 20) ? "all" : "20";
        const topNSel = buildSelect(
          "top_n",
          "Top:",
          [["5", "5"], ["10", "10"], ["15", "15"], ["20", "20"], ["30", "30"], ["all", "all"]],
          defaultTop,
        );

        SUMMARY_CONTROLS.appendChild(summarySetSel.parentElement);
        SUMMARY_CONTROLS.appendChild(speedMetricSel.parentElement);
        SUMMARY_CONTROLS.appendChild(summaryViewSel.parentElement);
        SUMMARY_CONTROLS.appendChild(topNSel.parentElement);

        for (const f of vfields) {
          const label = CONFIG_FIELDS.find(x => x[0] === f)?.[1] ?? f;
          const u = sortedUnique(f);
          const dd = buildMultiSelectDropdown(f, label, u);
          filterCheckboxes.set(f, dd.checkboxes);
          filterUpdaters.set(f, dd.update);
          SUMMARY_CONTROLS.appendChild(dd.wrap);
        }

      function makeTraces(rs, colorBy) {
        const baseCustom = r => [
          r.total,
          r.passed,
          (r.timed_out ?? 0),
          (r.timeout_rate ?? ((r.total && r.total > 0) ? ((r.timed_out ?? 0) / r.total) : 0)),
          r.time_s_avg,
          r.time_s_p50,
          r.time_s_p95,
        ];
        const hover =
          "%{text}" +
          "<br>pass_rate=%{y:.1%}" +
          "<br>sec/solve=%{x:.2f}" +
          "<br>avg_s=%{customdata[4]:.2f}" +
          "<br>p50_s=%{customdata[5]:.2f}" +
          "<br>p95_s=%{customdata[6]:.2f}" +
          "<br>passed=%{customdata[1]}/%{customdata[0]}" +
          "<br>timed_out=%{customdata[2]}/%{customdata[0]} (%{customdata[3]:.1%})" +
          "<extra></extra>";

        if (!colorBy || colorBy === "none") {
          return [{
            type: "scatter",
            mode: "markers",
            name: "configs",
            x: rs.map(r => r.sec_per_solve),
            y: rs.map(r => r.pass_rate),
            text: rs.map(r => label(r)),
            customdata: rs.map(baseCustom),
            hovertemplate: hover,
            marker: {
              size: 10,
              opacity: 0.9,
              color: "#2563eb",
              line: { width: 1, color: "rgba(0,0,0,0.18)" },
            },
          }];
        }

        const u = uniqVals(rs, colorBy);
        const sorted = u.slice().sort((a, b) => {
          const na = Number(a), nb = Number(b);
          if (!Number.isNaN(na) && !Number.isNaN(nb)) return na - nb;
          return String(a).localeCompare(String(b));
        });
        const traces = [];
        for (let i = 0; i < sorted.length; i++) {
          const v = sorted[i];
          const sub = rs.filter(r => r[colorBy] === v);
          const colorLabel = CONFIG_FIELDS.find(x => x[0] === colorBy)?.[1] ?? colorBy;
          traces.push({
            type: "scatter",
            mode: "markers",
            name: `${colorLabel}=${fmtValue(colorBy, v)}`,
            x: sub.map(r => r.sec_per_solve),
            y: sub.map(r => r.pass_rate),
            text: sub.map(r => label(r)),
            customdata: sub.map(baseCustom),
            hovertemplate: hover,
            marker: {
              size: 10,
              opacity: 0.9,
              color: PALETTE[i % PALETTE.length],
              line: { width: 1, color: "rgba(0,0,0,0.18)" },
            },
          });
        }
        return traces;
      }

      function truncate(s, maxLen) {
        const text = String(s ?? "");
        if (text.length <= maxLen) return text;
        return text.slice(0, Math.max(0, maxLen - 1)) + "…";
      }

      function axisLabel(r) {
        const parts = [];
        if (r.run_id !== undefined && r.run_id !== null) parts.push(`run=${r.run_id}`);
        for (const [f] of CONFIG_FIELDS) {
          if (!varying.get(f)) continue;
          const v = r[f];
          if (v === undefined || v === null) continue;
          parts.push(shortToken(f, v));
        }
        return parts.join(" ");
      }

      function summaryTitle(setName) {
        const context = [];
        if (fixed.benchmark !== null && fixed.benchmark !== undefined) {
          context.push(String(fixed.benchmark));
        }
        if (fixed.model !== null && fixed.model !== undefined) {
          context.push(String(fixed.model));
        }
        const contextText = context.length ? ` (${context.join(" | ")})` : "";
        return `Summary${contextText} — ${setName}`;
      }

        function renderSummary(rs, setName, speedField, viewMode) {
          const rows = rs
            .filter(r => r.pass_rate !== null && r.pass_rate !== undefined)
            .filter(r => r[speedField] !== null && r[speedField] !== undefined)
            .slice();

        const speedTitle =
          (speedMetricSel.options && speedMetricSel.selectedIndex >= 0)
            ? speedMetricSel.options[speedMetricSel.selectedIndex].textContent
            : speedField;

        if (rows.length === 0) {
          Plotly.react("summary", [], {
            title: summaryTitle(setName),
            template: "plotly_white",
          }, { displaylogo: false, responsive: true });
          return;
        }

        // Lower is better for speed metrics.
        rows.sort((a, b) => Number(a[speedField]) - Number(b[speedField]));

        const ids = rows.map((_, i) => String(i + 1));
        const ticks = rows.map(r => truncate(axisLabel(r) || "config", 64));
        const pass = rows.map(r => Number(r.pass_rate));
        const speed = rows.map(r => Number(r[speedField]));
        const details = rows.map(r => label(r));
        const totals = rows.map(r => Number(r.total ?? 0));
        const timedOut = rows.map(r => Number(r.timed_out ?? 0));
        const timeoutRates = rows.map((r, i) => {
          const fromRow = r.timeout_rate;
          if (fromRow !== undefined && fromRow !== null) return Number(fromRow);
          return totals[i] > 0 ? timedOut[i] / totals[i] : 0;
        });
        const summaryCustom = details.map((d, i) => [d, totals[i], timedOut[i], timeoutRates[i]]);

          const height = Math.max(260, Math.min(1400, 140 + rows.length * 28));
          const summaryDiv = document.getElementById("summary");
          if (summaryDiv) summaryDiv.style.height = height + "px";

          const overlay = (viewMode === "overlay");
          const passTrace = {
            type: "bar",
            orientation: "h",
            name: "pass_rate",
            x: pass,
            y: ids,
            xaxis: "x",
            marker: { color: overlay ? "rgba(37,99,235,0.70)" : "rgba(37,99,235,0.75)" },
            width: overlay ? 0.70 : undefined,
            customdata: summaryCustom,
            hovertemplate:
              "%{customdata[0]}" +
              "<br>pass_rate=%{x:.1%}" +
              "<br>timed_out=%{customdata[2]}/%{customdata[1]} (%{customdata[3]:.1%})" +
              "<extra></extra>",
          };
          const speedTrace = {
            type: "bar",
            orientation: "h",
            name: speedTitle,
            x: speed,
            y: ids,
            xaxis: "x2",
            marker: { color: overlay ? "rgba(17,24,39,0.28)" : "rgba(17,24,39,0.20)" },
            width: overlay ? 0.34 : undefined,
            customdata: summaryCustom,
            hovertemplate:
              "%{customdata[0]}" +
              "<br>" + speedTitle + "=%{x:.2f}" +
              "<br>timed_out=%{customdata[2]}/%{customdata[1]} (%{customdata[3]:.1%})" +
              "<extra></extra>",
          };

          Plotly.react("summary", [
            passTrace,
            speedTrace,
          ], {
            title: summaryTitle(setName),
            showlegend: false,
            barmode: "overlay",
            template: "plotly_white",
            margin: { t: overlay ? 80 : 60, r: 55, b: 30, l: 10 },
            yaxis: {
              tickvals: ids,
              ticktext: ticks,
              tickfont: { size: 11 },
              automargin: true,
              autorange: "reversed",
            },
            xaxis: {
              domain: overlay ? [0.0, 1.0] : [0.0, 0.47],
              title: "pass rate",
              tickformat: ".0%",
              range: [0, 1],
              gridcolor: "rgba(0,0,0,0.06)",
              zerolinecolor: "rgba(0,0,0,0.12)",
            },
            xaxis2: {
              domain: overlay ? [0.0, 1.0] : [0.53, 1.0],
              overlaying: overlay ? "x" : undefined,
              side: overlay ? "top" : undefined,
              title: speedTitle,
              rangemode: "tozero",
              showgrid: overlay ? false : true,
              gridcolor: "rgba(0,0,0,0.06)",
              zerolinecolor: "rgba(0,0,0,0.12)",
            },
            shapes: overlay
              ? []
              : [{
                type: "line",
                xref: "paper",
                yref: "paper",
                x0: 0.5,
                x1: 0.5,
                y0: 0,
                y1: 1,
                line: { color: "rgba(0,0,0,0.12)", width: 1 },
              }],
          }, {
            displaylogo: false,
            responsive: true,
          });
      }

        function perBenchmarkFrontiers(rs) {
          const byBench = new Map();
          for (const r of rs) {
            const b = r.benchmark ?? "";
            if (!byBench.has(b)) byBench.set(b, []);
            byBench.get(b).push(r);
          }
          const result = new Map();
          for (const [b, rows] of byBench.entries()) {
            result.set(b, paretoFrontier(rows));
          }
          return result;
        }

        function render() {
          for (const u of filterUpdaters.values()) u();
          const colorBy = colorBySel.value;
          const filters = currentFilters();
          const base = applyFilters(points, filters);

          const multiBench = uniqVals(base, "benchmark").length > 1;
          let frontierPts, frontierRows, benchFrontiers;
          if (multiBench) {
            benchFrontiers = perBenchmarkFrontiers(base);
            frontierPts = [];
            frontierRows = [];
            for (const [, pts] of benchFrontiers.entries()) {
              frontierPts.push(...pts);
              frontierRows.push(...pts.map(p => p.r));
            }
          } else {
            frontierPts = paretoFrontier(base);
            frontierRows = frontierPts.map(p => p.r);
            benchFrontiers = null;
          }

        let rs = base;
        if (onlyFrontierCb.checked) {
          const fset = new Set(frontierRows);
          rs = base.filter(r => fset.has(r));
        }

        const shownTotal = rs.reduce((acc, r) => acc + Number(r.total ?? 0), 0);
        const shownTimedOut = rs.reduce((acc, r) => acc + Number(r.timed_out ?? 0), 0);
        const shownTimeoutRate = shownTotal > 0 ? shownTimedOut / shownTotal : 0;
        const shownText =
          (base.length === points.length)
            ? `Showing ${base.length} configs. `
            : `Showing ${base.length} / ${points.length} configs (filtered). `;
        const shownTimeoutPct = (shownTimeoutRate * 100).toFixed(1);
        const timeoutText =
          `Timed out: ${shownTimedOut}/${shownTotal} (${shownTimeoutPct}%). `;
        const fixedText = fixedTokens.length ? `Fixed: ${fixedTokens.join(" ")}.` : "";
        const axisHelp = "X = seconds/solve (lower is better). Y = pass rate (higher is better). ";
        document.getElementById("subtitle").textContent =
          shownText + timeoutText + axisHelp + fixedText;

          const traces = makeTraces(rs, colorBy);
          if (paretoCb.checked) {
            if (benchFrontiers && benchFrontiers.size > 1) {
              const benchNames = Array.from(benchFrontiers.keys()).sort();
              for (let bi = 0; bi < benchNames.length; bi++) {
                const bPts = benchFrontiers.get(benchNames[bi]);
                if (!bPts || bPts.length < 2) continue;
                traces.push({
                  type: "scatter",
                  mode: "lines",
                  name: `Pareto: ${benchNames[bi]}`,
                  x: bPts.map(p => p.x),
                  y: bPts.map(p => p.y),
                  hoverinfo: "skip",
                  line: { color: PALETTE[bi % PALETTE.length], width: 2, dash: "dot" },
                  showlegend: false,
                });
              }
            } else if (frontierPts.length >= 2) {
              traces.push({
                type: "scatter",
                mode: "lines",
                name: "Best tradeoffs",
                x: frontierPts.map(p => p.x),
                y: frontierPts.map(p => p.y),
                hoverinfo: "skip",
                line: { color: "rgba(17,24,39,0.55)", width: 2, dash: "dot" },
              });
            }
          }

          Plotly.react("scatter", traces, {
            title: "Pass rate vs seconds/solve",
            xaxis: {
              title: { text: "seconds per solve (lower is better)", standoff: 18 },
              rangemode: "tozero",
            },
            yaxis: {
              title: { text: "pass rate (higher is better)", standoff: 10 },
              tickformat: ".0%",
              rangemode: "tozero",
            },
            legend: {
              orientation: "h",
              y: -0.50,
              yanchor: "top",
              x: 0,
              xanchor: "left",
            },
            margin: { t: 60, r: 20, b: 150, l: 65 },
            template: "plotly_white",
          }, {
          displaylogo: false,
          responsive: true,
        });

          const speedField = speedMetricSel.value;
          const summarySet = summarySetSel.value;
          const viewMode = summaryViewSel.value;
          let summaryRows = (summarySet === "shown") ? rs.slice() : frontierRows.slice();
          summaryRows = summaryRows
            .filter(r => r[speedField] !== null && r[speedField] !== undefined)
            .sort((a, b) => Number(a[speedField]) - Number(b[speedField]));

        const topVal = topNSel.value;
        if (topVal !== "all") {
          const n = parseInt(topVal, 10);
          if (!Number.isNaN(n) && n > 0) summaryRows = summaryRows.slice(0, n);
        }
          const summarySetName =
            (summarySetSel.options && summarySetSel.selectedIndex >= 0)
              ? summarySetSel.options[summarySetSel.selectedIndex].textContent
              : summarySet;
          renderSummary(summaryRows, summarySetName, speedField, viewMode);
        }

      colorBySel.addEventListener("change", render);
      paretoCb.addEventListener("change", render);
      onlyFrontierCb.addEventListener("change", render);
        for (const cbs of filterCheckboxes.values()) {
          for (const cb of cbs) cb.addEventListener("change", render);
        }
        summarySetSel.addEventListener("change", render);
        speedMetricSel.addEventListener("change", render);
        summaryViewSel.addEventListener("change", render);
        topNSel.addEventListener("change", render);

      render();
    </script>
  </body>
</html>
